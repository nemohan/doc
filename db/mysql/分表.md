# 分表(partition)

mysql的分表就是将一个表中的数据按一定条件划分成多个表（逻辑上还是只有一个表，但数据被存放在不同的物理文件中)，每个表存储满足指定条件的数据。分表不是在存储引擎层完成的，InnoDB、MyISAM、NDB等支持分表, CSV、FEDORATED等不支持。

mysql 只支持水平分表即将同一个表中不同的记录存放到不同的分表中。此外，MySQL的数据库分区是局部分区索引，一个分表中既存放了数据又存放了索引。全局索引是数据存放在各个分表中，但索引放在一个对象中。

#### 划分方法

* range：根据连续区间的列值的值确定行所在的分表
* list：根据一系列离散的列值确定行所在分表
* hash: 根据用户自定义的表达式返回值确定数据的分表，返回值不能为负数
* key: 根据mysql数据库提供的哈希函数来分表。

限制：不论那种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分

##### range 

~~~mysql
create table t(id int)engine=Innodb
partition by range(id)(
partition p0 values less than(10),
partition p1 values less than(20));

insert into t select 5;
insert into t select 6;
~~~

查看分表信息:

向t中插入2条数据后，可以看到p0中有两条数据(TABLE_ROWS)。p1中没有数据

~~~mysql
# database() 返回当前数据库名称
mysql> select * from information_schema.PARTITIONS where table_schema=database() and table_name='t' \G;
*************************** 1. row ***************************
                TABLE_CATALOG: def
                 TABLE_SCHEMA: spider
                   TABLE_NAME: t
               PARTITION_NAME: p0
            SUBPARTITION_NAME: NULL
   PARTITION_ORDINAL_POSITION: 1
SUBPARTITION_ORDINAL_POSITION: NULL
             PARTITION_METHOD: RANGE
          SUBPARTITION_METHOD: NULL
         PARTITION_EXPRESSION: id
      SUBPARTITION_EXPRESSION: NULL
        PARTITION_DESCRIPTION: 10
                   TABLE_ROWS: 2
               AVG_ROW_LENGTH: 8192
                  DATA_LENGTH: 16384
              MAX_DATA_LENGTH: NULL
                 INDEX_LENGTH: 0
                    DATA_FREE: 0
                  CREATE_TIME: 2019-12-26 09:45:25
                  UPDATE_TIME: NULL
                   CHECK_TIME: NULL
                     CHECKSUM: NULL
            PARTITION_COMMENT:
                    NODEGROUP: default
              TABLESPACE_NAME: NULL
*************************** 2. row ***************************
                TABLE_CATALOG: def
                 TABLE_SCHEMA: spider
                   TABLE_NAME: t
               PARTITION_NAME: p1
            SUBPARTITION_NAME: NULL
   PARTITION_ORDINAL_POSITION: 2
SUBPARTITION_ORDINAL_POSITION: NULL
             PARTITION_METHOD: RANGE
          SUBPARTITION_METHOD: NULL
         PARTITION_EXPRESSION: id
      SUBPARTITION_EXPRESSION: NULL
        PARTITION_DESCRIPTION: 20
                   TABLE_ROWS: 0
               AVG_ROW_LENGTH: 0
                  DATA_LENGTH: 16384
              MAX_DATA_LENGTH: NULL
                 INDEX_LENGTH: 0
                    DATA_FREE: 0
                  CREATE_TIME: 2019-12-26 09:45:25
                  UPDATE_TIME: NULL
                   CHECK_TIME: NULL
                     CHECKSUM: NULL
            PARTITION_COMMENT:
                    NODEGROUP: default
              TABLESPACE_NAME: NULL
2 rows in set (0.00 sec)

ERROR:
No query specified
~~~

注意事项:

* 若插入一个不在分区定义的值时，mysql会抛出异常。如在上面的表t中执行下列语句insert into t select 30
* 针对range分表的查询，优化器只能对YEAR(), TO_DAYS(), TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化选择

##### list 

~~~mysql
create table t(
a int,
b int
)engine=innodb
partition by list(b)(
partition p0 values in(1, 2),
partition p1 values in(3, 4))
~~~

注意事项:

* 插入的值不在分区的定义中，mysql数据库会抛出异常。
* 插入多行数据过程中遇到分区未定义的值，MyISAM会将之前的行数据都插入，之后的数据会插入失败。InnoDB 则将其视为一个事务，因此没有任何数据插入

##### HASH

HASH 分区可以将数据均匀地分布，保证各分表的数据量大致一样。

~~~mysql
create table t_hash(
a int
b datetime
)engine=Innodb
PARTITION BY HASH(year(b))
PARTITIONS 4;
~~~

##### COLUMNS 



##### key

KEY 分表和HASH分表相似，不同之处在于HASH分区使用用户定义的函数，KEY分表使用MySQL数据库提供的函数进行分表。

##### 子分表