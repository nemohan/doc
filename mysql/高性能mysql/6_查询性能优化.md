# 6  查询优化

5.6版本

#### 1 查询为何会慢

* 是否查询了不必要的数据,不需要的列、行（比如select *这种形式，无法使用cover index)

* mysql是否处理了较多的不必要数据以得到一个较小的结果集

  原文:

  1. Find out whether your application is retrieving more data than you need. That
     usually means it’s accessing too many rows, but it might also be accessing too many
     columns.
2.  	Find out whether the MySQL server is analyzing more rows than it needs

###### 优化数据访问

* 从较大的结果集获取一个较小的结果集。如未使用limit
* 在多表连接查询中获取了所有表的列，如 select * from a inner join b using(id)
* 使用select * 获取所有列,无法使用cover index
* 重复获取同样的数据



#### 观察慢查询的几个方面

* 响应时间
* 处理的结果集
* 返回的结果集



#### 3 查询重构

* 分解连接(join)查询
* 大任务分解成小任务
* 复杂查询分解。一个大的sql语句分解成多个小的单独的sql语句

#### 4 查询的执行过程

1 客户端发送命令到数据库

2 是否命中缓存

3 解析查询sql，优化sql为qep(query execution plan)

* join 优化器
* sort优化。优化手段包括使用索引。

4 执行qep

5 返回结果



#### COUNT()

count(*)是统计结果集的行数。count(column_name)是统计column_name的值不为NULL的个数.

若存储引擎是myISAM, 并且没有WHERE 限制条件。count(*)统计表的行数是个常量。因为myISAM引擎已经存储了当前表的行数

其他方式: 用其他表来存储类似COUNT()的统计信息

~~~mysql
在一条sql 里面使用多个count
SELECT SUM(IF (color="blue", 1, 0)) AS blue, SUM(IF color="red", 1, 0) AS red FROM items;

mysql> SELECT COUNT(color = 'blue' OR NULL) AS blue, COUNT(color = 'red' OR NULL)
-> AS red FROM items;
~~~



pos_order 有主键 id。本以为count(*)会使用主键来统计行数，实际用了另一个唯一索引。大概是因为主键是cluseter index，数据量比较大。

~~~mysql
mysql> explain select count(*) from pos_order \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: pos_order
         type: index
possible_keys: NULL
          key: outTradeNo
      key_len: 258
          ref: NULL
         rows: 4872
        Extra: Using index
1 row in set (0.01 sec)
~~~



#### JOIN

#### LIMIT and OFFSET()

SELECT * FROM table1 LIMIT 100 OFFSET 10000; 

这种语句会导致sql查询10100条结果然后丢弃掉前面的10000条数据。

两种方式可以优化类似语句:

SELECT * FROM table1 WHERE id < 1000  LIMIT 100 order by id;



~~~sql
 
 方式2： film_id上有索引
 SELECT film.film_id, film.description
-> FROM sakila.film
-> INNER JOIN (
-> SELECT film_id FROM sakila.film
-> ORDER BY title LIMIT 50, 5
-> ) AS lim USING(film_id);
~~~



#### 子查询

对于当前版本来说，尽量使用join代替子查询

