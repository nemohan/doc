# 复制算法



### 基本的算法:

* 堆一分为2，其中一个用来进行内存分配，假设是From。另一个假设命名为To。
* 执行GC时，从根开始遍历将活动对象拷贝到To空间并更新引用关系
* 复制完成后交换From 和To指向的空间

~~~
|-----------------------------|-----------------------------
|							  |				
|	     from				  |			to 	
|-----------------------------|-----------------------------
~~~

重点是复制时更新引用关系

缺点：一半的空间不能被使用。

#### 深度优先复制

从roots(根)开始，将一个根引用的对象、直至所有间接被引用的对象被复制完成，然后从另一个根开始从夫上述操作，直到所有的根。跟图的深度优先遍历类似

伪码描述：

~~~
def collect():
	free = to_space
	for r in roots:
		r = copy(r)
	swap(from_space, to_space)
	
//下面的代码会导致重复拷贝
def copy(r):
	if r <= to_space:
		copy_data(free, r, r.size)
		//new_addr = to_start
		r.forwarded = free
		free += r.size
		for c in children(r):
			r.c = copy(c)
	return r.forwarded //new_addr

/***********************************
//一开始我认为对象的forwarded字段非必须的。而且有forwarded字段时何时将其置空呢
//forwarded的正解: 1 必须有，用于标识对象是否被拷贝过 2 无须置空，因为设置的是拷贝之前的对象。拷贝之后在to空间的对象并没有设置此字段。发明这算法的人确实NB :)
********************************************/
//为什么此处的
def copy(r):
	if r.forwarded is None:
		copy_data(free, r, r.size)
		r.forwarded = free
		free += r.size
		for c in children(r):
			r.c = copy(c)
	return r.forwarded
def copy_data(src, dst,size):
	memcpy(src,dst, size)
	
~~~



#### 广度优先复制(Cheney's copying GC)

从根开始，先将所有被根直接引用的对象复制到To空间，然后是第二层被间接引用的对象

~~~
def collect():
	free = to_space
	for r in roots:
		r = copy_roots(r)
	queue_begin = to_space
	copy()
def copy_roots(r):
	if r <= to_space:
		copy_data(to_start, r, r.size)
		r.forwarded = to_start
		free += r.size
	return r.forwarded
	
def copy(r):
	while queue_begin < free:
		if r.forwarded is None:
			for c in children(r):
				r.c = copy_data(free, r, r.size)
				r.forwared = free
				free += r.size
		queue_begin += r.size		
	
def copy_data(src, dst, size):
	memcpy(to_start)
~~~



#### 近似深度优先复制

### 多空间复制算法

多空间复制算法的思想是将堆分成N(N>2)份，整个空间使用复制算法+标记-清扫算法。多空间复制算法可以提升堆的利用率。

堆的划分如下图所示：

~~~
|------------|----------------|------------------|----------
|			 |			  	  |					 |
|	     to  |		from	  |	mark-sweep		 | mark-s
|------------|----------------|------------------|----------

复制完成后：
|------------|----------------|------------------|----------
|			 |			  	  |					 |
|	from     |		to		  |	mark-sweep		 | mark-s
|------------|----------------|------------------|----------

~~~

基本步骤:

* 使用复制算法将from空间的对象复制到to空间
* 其他空间使用标记-清扫算法
* 复制算法完成后，to = from, from = (to + 1) %N

### Mostly-copying GC(大部分复制算法)

A copying GC can also be used in situations where not all pointers can be identified unambiguously. This is the idea of
mostly-copying GC, due to Bartlett. In such a GC, objects are partitioned in two classes:

1. those for which some pointers are ambiguous, usually because they appear in the stack or registers,
2. those for which all pointers are known unambiguously. Objects of the first class are pinned, i.e. left where they are,
  while the others — the vast majority, generally — are copied as usual.



Objects cannot be pinned if the from and to spaces are organized as two separate areas of memory, because  from-space must be completely empty after GC.
Therefore, a mostly-copying GC organizes memory in pages of fixed size, tagged with the space to which they belong.
Then, during GC :
– pinned objects are left on their page, whose tag is updated to "move" them to to-space,
– other objects are copied (and compacted) as usual.

