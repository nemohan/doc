# 复制算法



### 基本的算法:

* 将堆等分为2个空间，其中一个用来进行内存分配，假设是From。另一个假设命名为To。
* 执行GC时，从根开始遍历将活动对象拷贝到To空间并更新引用关系
* 复制完成后交换From 和To指向的空间

~~~
|-----------------------------|-----------------------------
|						    |				
|	     from				|			to 	
|-----------------------------|-----------------------------
~~~

重点是复制时更新引用关系

缺点：一半的空间不能被使用。

优势：无需维护空闲空间列表，所以可以快速分配内存

#### 深度优先复制

从roots(根)开始，将一个根引用的对象、直至所有间接被引用的对象被复制完成，然后从另一个根开始从夫上述操作，直到所有的根。跟图的深度优先遍历类似

伪码描述：

~~~
def allocate(size):
	if free + size < end:
		free += size
		return free -size
	collect()
	return allocate(size)

def collect():
	free = to_space
	for r in roots:
		r = copy(r)
	swap(from_space, to_space)
	
//下面的代码会导致重复拷贝,同一个对象被多个根引用时
def copy(r):
	if r <= to_space:
		copy_data(free, r, r.size)
		//new_addr = to_start
		r.forwarded = free
		free += r.size
		for c in children(r):
			r.c = copy(c)
	return r.forwarded //new_addr

/***********************************
//一开始我认为对象的forwarded字段非必须的。而且有forwarded字段时何时将其置空呢
//forwarded的正解: 1 必须有，用于标识对象是否被拷贝过 2 无须置空，因为设置的是拷贝之前的对象。拷贝之后在to空间的对象并没有设置此字段。发明这算法的人确实NB :)
********************************************/
//为什么此处的
def copy(r):
	if r.forwarded is None:
		copy_data(free, r, r.size)
		r.forwarded = free
		free += r.size
		for c in children(r):
			r.c = copy(c)
	return r.forwarded

~~~



#### 广度优先复制(Cheney's copying GC)

从根开始，先将所有被根直接引用的对象复制到To空间，然后是第二层被间接引用的对象。Cheney's 复制算法的聪明之处在于没有使用额外的存储空间来维护FIFO队列，而是维护了一个指向未处理对象的(队列头)的指针scan,scan和free之间的对象即为队列中待处理的对象。

~~~
def collect():
	free = to_space
	scan = to_space
	for r in roots:
		r = copy_roots(r)
	copy()
	swap(from_space, to_space)
def copy_roots(r):
	if r <= to_space:
		copy_data(free, r, r.size)
		r.forwarded = free
		free += r.size
	return r.forwarded
	
def copy(r):
	while scan < free:
		if r.forwarded is None:
			for c in children(r):
				r.c = copy_data(free, r, r.size)
				r.forwared = free
				free += r.size
		scan += r.size		
	
~~~



#### 近似深度优先复制

### 多空间复制算法

多空间复制算法的思想是将堆分成N(N>2)份，整个空间使用复制算法+标记-清扫算法。多空间复制算法可以提升堆的利用率。

堆的划分如下图所示：

~~~
|------------|----------------|------------------|----------
|			 |			  	  |					 |
|	     to  |		from	  |	mark-sweep		 | mark-s
|------------|----------------|------------------|----------

复制完成后：
|------------|----------------|------------------|----------
|			 |			  	  |					 |
|	from     |		to		  |	mark-sweep		 | mark-s
|------------|----------------|------------------|----------

~~~

基本步骤:

* 使用复制算法将from空间的对象复制到to空间
* 其他空间使用标记-清扫算法
* 复制算法完成后，to = from, from = (to + 1) %N



深度优先、广度优先、近似深度优先拷贝完成后堆中对象排列的示意图:

![image-20191217113942863](E:\doc\GC\${img}\image-20191217113942863.png)



### Mostly-copying GC(大部分复制算法)

A copying GC can also be used in situations where not all pointers can be identified unambiguously. This is the idea of
mostly-copying GC, due to Bartlett. In such a GC, objects are partitioned in two classes:

1. those for which some pointers are ambiguous, usually because they appear in the stack or registers,
2. those for which all pointers are known unambiguously. Objects of the first class are pinned, i.e. left where they are,
    while the others — the vast majority, generally — are copied as usual.



Objects cannot be pinned if the from and to spaces are organized as two separate areas of memory, because  from-space must be completely empty after GC.
Therefore, a mostly-copying GC organizes memory in pages of fixed size, tagged with the space to which they belong.
Then, during GC :
– pinned objects are left on their page, whose tag is updated to "move" them to to-space,
– other objects are copied (and compacted) as usual.

