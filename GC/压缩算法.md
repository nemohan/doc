# `标记压缩算法

2019/11/13

### 标记压缩算法

算法描述:

~~重新移动活动对象，使得每个活动对象之间不存在空闲空间~~。重新安排散落在堆内对象的位置，压缩对象之间的空闲空间并所有对象在堆的一端紧密排列。如下图所示

~~~

used: 标记被对象使用的空间
反之是未使用的空闲空间
压缩前:
|-----------|-----------|-----------|-----------|--------------
|used		|			|used		|			|used
|	     	|			|			|			|
|-----------|-----------|-----------|-----------|---------------

压缩后:
|-----------|-----------|-----------|-----------|--------------
|used		|used		|used		|			|
|	     	|			|			|			|
|-----------|-----------|-----------|-----------|---------------
~~~

今天跟同事聊起标记-压缩算法，只记得基本思想是重新移动对象。具体的细节没什么印象了(细节没跟同事解释清除,看来还是没有深刻理解)。假如让我实现该算法我该怎么做呢？所以尝试实现算法理清楚主要的逻辑应该会加深我对此的理解

压缩算法的基本思想是移动对象，那应该主要有两点: 

1 既然是移动对象，首先需要知道哪些对象要移动，必然是可以从根到达的对象。这就涉及一个标记步骤

2 移动后，对象之间的引用关系须保持不变 。难点在于第二步，移动对象并保持对象之间的引用关系

开始想出来的解决方案是:

1 标记活动对象

2 顺序扫描堆，计算活动对象的新位置并保存在对象中

3 顺序扫描堆，移动对象

这个解决方案很显然会导致对象间引用关系被破坏，移动对象时无法更新引用关系



方案2：

1 标记活动对象

2 从根

下面就是自己整理得出的四个步骤，符合Lisp2算法的步骤:

1 标记活动对象

2 顺序扫描堆，计算活动对象的新位置。将新位置信息保存到对象中

3 从根开始，遍历活动对象，用对象的新位置更新对象之间的引用

4 顺序扫描堆，移动对象到新位置

第三步更新引用的同时，移动对象可不可以？不可以，此时移动对象会导致对象被覆盖

第四步的顺序扫描堆，改成从根开始遍历对象移动到新位置可不可以?不可用，会导致对象被覆盖

~~1 假设我直接从roots开始，找到一个对象便进行移动到前面位置。遇到的第一个问题就是前面的对象可能会被覆盖。既然这种方法不行，那该怎么办呢？先标记找到的每个对象。~~

~~2  顺序扫描堆，移动遇到的每个被标记的对象。假设被移动的对象是A，A移动完成之后。移动被A引用的其他对象B时，不能更新A指向B的指针。~~



### Two-Finger 算法

该算法要求每个对象占用大小相等的空间。

Two-Finger算法步骤:

* 标记活动对象

* 从堆的两端开始扫描，从前向后扫描找到第一个空闲块；从后向前扫描找到第一个被标记的对象，复制到找到的第一个空闲块

* 更新引用关系(用对象的新位置更新引用该对象的对象)

  

### 间隙表格算法

待深入了解



### Immix 算法

待了解