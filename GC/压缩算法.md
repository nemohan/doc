# 标记压缩算法

2019/11/13

### 标记压缩算法

算法描述:

~~重新移动活动对象，使得每个活动对象之间不存在空闲空间~~。重新安排散落在堆内的活动对象的位置，压缩对象之间的空闲空间并所有对象在堆的一端紧密排列。如下图所示

~~~

used: 标记被对象使用的空间
反之是未使用的空闲空间
压缩前:
|-----------|-----------|-----------|-----------|--------------
|used		|			|used		|			|used
|	     	|			|			|			|
|-----------|-----------|-----------|-----------|---------------

压缩后:
|-----------|-----------|-----------|-----------|--------------
|used		|used		|used		|			|
|	     	|			|			|			|
|-----------|-----------|-----------|-----------|---------------
~~~

今天跟同事聊起标记-压缩算法，只记得基本思想是重新移动对象。具体的细节没什么印象了(细节没跟同事解释清除,看来还是没有深刻理解)。假如让我实现该算法我该怎么做呢？所以尝试实现算法理清楚主要的逻辑应该会加深我对此的理解

压缩算法的基本思想是移动对象，那应该主要有两点: 

1 既然是移动对象，首先需要知道哪些对象要移动，必然是可以从根到达的对象。这就涉及一个标记步骤

2 移动后，对象之间的引用关系须保持不变 。难点在于第二步，移动对象并保持对象之间的引用关系

开始想出来的解决方案是:

1 标记活动对象

2 顺序扫描堆，计算活动对象的新位置并保存在对象中

3 顺序扫描堆，移动对象

这个解决方案很显然会导致对象间引用关系被破坏，移动对象时无法更新引用关系



方案2：

1 标记活动对象

2 从根

下面就是自己整理得出的四个步骤，符合Lisp2算法的步骤:

1 标记活动对象

2 顺序扫描堆，计算活动对象的新位置。将新位置信息保存到对象中

3 从根开始，遍历活动对象，用对象的新位置更新对象之间的引用

4 顺序扫描堆，移动对象到新位置

第三步更新引用的同时，移动对象可不可以？不可以，此时移动对象会导致对象被覆盖

第四步的顺序扫描堆，改成从根开始遍历对象移动到新位置可不可以?不可以，会导致对象被覆盖

~~1 假设我直接从roots开始，找到一个对象便进行移动到前面位置。遇到的第一个问题就是前面的对象可能会被覆盖。既然这种方法不行，那该怎么办呢？先标记找到的每个对象。~~

~~2  顺序扫描堆，移动遇到的每个被标记的对象。假设被移动的对象是A，A移动完成之后。移动被A引用的其他对象B时，不能更新A指向B的指针。~~

伪码描述:

~~~
def markFromRoots():
	for r in roots:
		mark(r)		
		
def mark(o):
	if o.marked == False:
		o.marked = True
		for c in children(o):
			mark(o)

def compact_phase():
	compute_new_pos()
	update()
	move()
	
//计算新位置			
def compute_new_pos():
	scan = heap_start
	free = heap_start
	while scan < heap_end:
		if scan.marked == True:
			scan.forwarded = free
			free.size += scan.size
		scan += scan.size
		

//*********mine begin**************
def update():
	for r in roots:
		r = update_object(r)
def update_object(o):
	if o.updated == False:
		o.updated = True
		for c in children(o):
			o.c = update_object(c)
	return r.forwarded
	
//************* mine end************

	
def move():
	scan = heap_start
	while scan < heap_end:
		if scan.marked == True:
			scan.marked = False
			scan.updated = False
			memcpy(scan.forwarded, scan, scan.size)
		scan += scan.size
	
~~~

##### 进行GC的时机

分配失败时，使用压缩算法的分配方式是顺序分配

### Two-Finger 算法

该算法要求每个对象占用大小相等的空间。



Two-Finger算法步骤:

* 标记活动对象

* 从堆的两端开始扫描，从前向后扫描找到第一个空闲块；从后向前扫描找到第一个被标记的对象，复制到找到的第一个空闲块

* 更新引用关系(用对象的新位置更新引用该对象的对象)

  
  
  

伪码描述:

~~~
def markFromRoots():
	for r in roots:
		mark(r)		
		
def mark(o):
	if o.marked == False:
		o.marked = True
		for c in children(o):
			mark(o)

//如何更新指针
/*******************
方案1: 先计算移动位置，计算的位置保存到每个对象。
从根遍历


********************/
def compact():
	free = heap_start
	scan = heap_end
	while  free < scan:
		while free.marked == True:
			free += free.size
		while scan.marked == False:
			scan -= scan.size
		//拷贝对象，可以在这进行，拷贝之后从根遍历仍然可以找到
		//被拷贝的对象
		//memcpy(free, scan, scan.size)
		scan.forwarded = free
		
def move_obj():
	for r in roots:
		r = move(r)
def move(o):
	if r.forwarded not None:
		memcpy(r.forwarded, r, r.size)
		for c in children(o):
			move(c)
			
//===============方案2 代码
		

~~~



### 间隙表格算法

待深入了解



### Immix 算法

待了解