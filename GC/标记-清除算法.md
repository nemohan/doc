# 标记-清除(mark-sweep)算法

### mark-sweep (标记-清除算法)

标记-清除算法基本思想是标记活动对象，回收没有被标记的对象

算法描述：

* 标记阶段，标记从根可以到达的所有对象
* 清扫阶段，回收未标记的对象到空闲链表


变量说明:

~~~
roots 根
heap_start 指向堆的开始位置
heap_end 指向堆的结束位置
free_start 指向堆的当前分配位置
free_list 空闲内存块链表
~~~



伪码描述:

~~~
mark_and_sweep():
	for r in roots:
		mark(r)
		
def mark(o):
	for c in children(o):
		if not c.marked:
			c.marked = True
			mark(c)
			
def sweep():
	h = heap_start
	while h < heap_end:
		if h.marked == False
			h.next = free_list
			free_list = h
			h += h.size
		else:
			h.marked == False

分配内存
def allocate(size):
	if free_start + size < heap_end:
		free_start.size = size
		free_start += size
		return free_start
	//从空闲链表分配
	else:
		h = free_list
		while h not None:
			if h.size >= size:
				//TODO:
				return h
			h = h.next
		
	
	//空闲链表分配失败则调用mark_and_sweep
	mark_and_sweep()
	return allocate()
	
~~~



分配内存可用的策略：Best-Fit、First-Fit、Worst-Fit

缺点：

* 内存碎片化
* 采用Best-Fit策略分配空间时会导致查找时间较长
* 缓存不友好，修改每个对象的标记位

#####  多空闲链表

回收对象时，可以根据对象占用空间大小将对象放到不同的空闲链表。比如大小为2、4、8、16等字节的链表。分配时根据要求的大小去对应的空闲链表分配。

##### 位图算法 (bitmap)

将对象的标记位从对象中剥离出来放到位图中。那么应该是1位对应固定大小的字节数。若1位表示字节数太小，如4字节，那么表示4G内存需要128M内存未免浪费。若表示16字节，则只需要32M内存

##### BiBOP



##### 延迟清扫算法(lazy-sweep)

延迟清扫算法的要点是在标记完之后，不去清扫整个堆而是在分配时去清扫。最简单的形式是找到一个大小合适的空间，就清扫结束。

找到第一个大小合适的空间时结束本次扫描：

~~~
def mark_and_sweep():
	for r in roots:
		mark(r)
def mark(o):
	for c in children(o):
		if not c.marked:
			c.marked = True
			mark(c)

def allocate(size):
	start = heap_start
	while start < heap_end:
		if h.marked:
			h.marked = False
		if h.size > size:
			return h
		
~~~



二

~~~

~~~



