# 引用计数算法



### 基本算法

每个对象维护一个当前对象被多少个对象引用的计数，当该计数为0时。表明当前对象可以被释放了。该算法的逻辑比较简单

优点：

缺点：

不能回收循环引用的对象

伪代码描述：

分配对象

~~~
new_obj(size)
	obj = pickup_chunk(size, &free_list)
	if(obj == NULL)
		allocation_fail()
	else
		obj.ref_cnt = 1
		return obj
~~~

更新指针:

~~~
update_ptr(ptr, obj)
	inc_ref_cnt(obj)
	dec_ref_cnt(*ptr)
	*ptr = obj
~~~

增加计数:

~~~
inc_ref_cnt(obj)
	obj.ref_cnt++
~~~

减少计数:

~~~
dec_ref_cnt(obj)
	obj.ref_cnt--
	if(obj.ref_cnt ==  0)
		for(child: children(obj))
			dec_ref_cnt(*child)
		reclaim(obj)
~~~



### 延迟引用计数法



### sticky 算法



### 引用计数结合标记-清除算法