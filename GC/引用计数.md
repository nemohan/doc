# 引用计数算法



### 基本算法

每个对象维护一个当前对象被多少个对象引用的计数，当该计数为0时。表明当前对象可以被释放了。该算法的逻辑比较简单

优点：

缺点：

不能回收循环引用的对象

伪代码描述：

分配对象

~~~
new_obj(size)
	obj = pickup_chunk(size, &free_list)
	if(obj == NULL)
		allocation_fail()
	else
		obj.ref_cnt = 1
		return obj
~~~

更新指针:

~~~
update_ptr(ptr, obj)
	inc_ref_cnt(obj)
	dec_ref_cnt(*ptr)
	*ptr = obj
~~~

增加计数:

~~~
inc_ref_cnt(obj)
	obj.ref_cnt++
~~~

减少计数:

~~~
dec_ref_cnt(obj)
	obj.ref_cnt--
	if(obj.ref_cnt ==  0)
		for(child: children(obj))
			dec_ref_cnt(*child)
		reclaim(obj)
~~~



### 延迟引用计数法

没怎么看明白

### sticky 算法

在基本的引用计数算法中，引用计数的类型大小一般是一个机器字(4字节32位系统或8字节64位系统)。这样在对象很小的情况下比如2个字大小时，50%的空间是不能使用的。为了减少浪费，可以只使用几个位来表示引用计数大小比如4位，但是这样又容易导致溢出在计数超过16的时候。这时候应该怎么清除计数溢出的对象呢，可以在某个时刻使用标记-清扫算法

步骤:

* 减引用计数时，如果计数为0。回收对象
* 在某个时刻，将从根

### 引用计数结合标记-清除算法