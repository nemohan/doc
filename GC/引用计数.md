# 引用计数算法



### 基本算法

每个对象维护一个当前对象被多少个对象引用的计数，当该计数为0时。表明当前对象可以被释放了。该算法的逻辑比较简单

优点：

缺点：

不能回收循环引用的对象

伪代码描述：

分配对象

~~~
new_obj(size)
	obj = pickup_chunk(size, &free_list)
	if(obj == NULL)
		allocation_fail()
	else
		obj.ref_cnt = 1
		return obj
~~~

更新指针:

~~~
update_ptr(ptr, obj)
	inc_ref_cnt(obj)
	dec_ref_cnt(*ptr)
	*ptr = obj
~~~

增加计数:

~~~
inc_ref_cnt(obj)
	obj.ref_cnt++
~~~

减少计数:

~~~
dec_ref_cnt(obj)
	obj.ref_cnt--
	if(obj.ref_cnt ==  0)
		for(child: children(obj))
			dec_ref_cnt(*child)
		reclaim(obj)
~~~



### 延迟引用计数法

没怎么看明白

### sticky 算法

在基本的引用计数算法中，引用计数的类型大小一般是一个机器字(4字节32位系统或8字节64位系统)。这样在对象很小的情况下比如2个字大小时，50%的空间是不能使用的。为了减少浪费，可以只使用几个位来表示引用计数大小比如4位，但是这样又容易导致溢出在计数超过16的时候。这时候应该怎么清除计数溢出的对象呢，可以在某个时刻使用标记-清扫算法

~~自己没有理解:~~

* ~~减引用计数时，如果计数为0。回收对象~~
* ~~顺序扫描堆，所有对象的引用计数器置为0~~
* ~~从根遍历每个对象，遍历到的对象的计数器加1~~
* ~~顺序扫描堆，回收所有计数器为0的对象~~

~~如果是这样，计数就没有意义了。还不如使用标记清扫-算法，之所以得出上面得算法步骤，是自己将多种引用计数算法张冠李戴了。~~

我的理解：

* 首先，需要区分对象得引用计数是不是溢出了。只有在没有溢出的情况下，计数减为0时释放对象才是可行的。对已经溢出的对象可以不用去减引用计数(减计数释放对象也不可行)。所以标记-清扫的目的也就是回收这部分计数溢出的对象。
* 接下来的问题就是怎么用标记-清扫算法回收计数溢出的对象。一种方法就是从根遍历对象标记溢出的对象。清扫阶段，顺序扫描堆回收被标记的对象

书上给出的算法：

#### 1 位引用计数法

### 引用计数结合标记-清除算法