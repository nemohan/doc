# 引用计数算法



### 基本算法

每个对象维护一个当前对象被多少个对象引用的计数，当该计数为0时。表明当前对象可以被释放了。该算法的逻辑比较简单

优点：

缺点：

不能回收循环引用的对象

伪代码描述：

分配对象

~~~
new_obj(size)
	obj = pickup_chunk(size, &free_list)
	if(obj == NULL)
		allocation_fail()
	else
		obj.ref_cnt = 1
		return obj
~~~

更新指针:

~~~
update_ptr(ptr, obj)
	inc_ref_cnt(obj)
	dec_ref_cnt(*ptr)
	*ptr = obj
~~~

增加计数:

~~~
inc_ref_cnt(obj)
	obj.ref_cnt++
~~~

减少计数:

~~~
dec_ref_cnt(obj)
	obj.ref_cnt--
	if(obj.ref_cnt ==  0)
		for(child: children(obj))
			dec_ref_cnt(*child)
		reclaim(obj)
~~~



### 延迟引用计数法

没怎么看明白

### sticky 引用计数法

在基本的引用计数算法中，引用计数的类型大小一般是一个机器字(4字节32位系统或8字节64位系统)。这样在对象很小的情况下比如2个字大小时，50%的空间是不能使用的。为了减少浪费，可以只使用几个位来表示引用计数大小比如4位，但是这样又容易导致溢出在计数超过16的时候。这时候应该怎么清除计数溢出的对象呢，可以在某个时刻使用标记-清扫算法

回忆:

* 减引用计数时，如果计数为0。回收对象
* 顺序扫描堆，所有对象的引用计数器置为0
* 从根遍历每个对象，遍历到的对象的计数器加1
* 顺序扫描堆，回收所有计数器为0的对象

如果是这样，计数就没有意义了。还不如使用标记清扫-算法，之所以得出上面得算法步骤，是自己将多种引用计数算法张冠李戴了。2019/11/15

<font color="red">后来又去看了一遍sticky引用计数法，上面的思路大体是对的。但有几个细节有缺陷</font>

* 第一步，减引用计数，只能针对计数器未溢出的对象
* 顺序扫描堆，所有对象的引用计数器置为0,这一步之所以必要是因为可以回收存在循环引用的对象
* 从根遍历每个对象，遍历到的对象的计数器加1。这一步可以恢复对象被置为0之前的引用计数
* 顺序扫描堆，回收所有计数器为0的对象

个人理解(2019/11/15)：

* 首先，需要区分对象得引用计数是不是溢出了。只有在没有溢出的情况下，计数减为0时释放对象才是可行的。对已经溢出的对象可以不用去减引用计数(减计数释放对象也不可行)。所以标记-清扫的目的也就是回收这部分计数溢出的对象。
* 接下来的问题就是怎么用标记-清扫算法回收计数溢出的对象。一种方法就是从根遍历对象标记溢出的对象。清扫阶段，顺序扫描堆回收被标记的对象

个人得出的算法的缺陷是不能回收存在循环引用的对象。



#### 1 位引用计数法

1位引用计数法是stiky计数法的一个极端情况

### 部分标记-清除算法

部分标记-清除算法的目的是回收存在循环引用的对象。那么问题来了，如何找出存在循环引用的对象呢？

通过着色来标记对象：

* 黑色 绝对不是垃圾的对象

* 灰色 搜索完成对象

* 白色 垃圾对象

* 红色 正在搜索对象

算法：

* 减引用计数，计数为0时释放对象。不为0时将对象涂上红色。进入红色对象队列
* 分配内存时，无可用空间。扫描红色队列尝试释放红色对象
* 搜索红色对象，先将对象颜色置为黑色,红色对象的子对象可能是红色、黑色、灰色中的一种。若为灰色，则不必进一步处理。若为黑色或红色将其置为灰色，计数减1。