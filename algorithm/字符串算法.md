# 字符串算法

[TOC]

### 常见的字符串存储结构

* 单词查找树trie
* 后缀树(suffix trie、suffix tree)
* 后缀数组(suffix array)

### 字符串排序

##### 键索引计数法

##### 低位优先的字符串排序



### 单词查找树

#### trie(try发音)

trie是一棵树，每个节点有n条边（边的数目以存储的字符的字符表大小而定，若只存储包含a-z的字符串，则n就是26。若存储ascii字符，则大小为128）。每个节v点对应一个字符，对应的字符由其父节点p指向当前子节点边隐式确定

查找指定的字符串的时间复杂度是O(L),L是字符串长度

![1597038081877](${img}/1597038081877.png)



![1597038113269](${img}/1597038113269.png)



##### 应用

* 前缀匹配 keysWithPrefix("sa")， 找出前缀为指定字串的所有字符串
* 最长前缀longestPrefixOf("sample"),  找出含有给定字串的最长前缀的字符串

##### Trie的定义

使用数组表示边，会产生很多浪费。可以使用以下几种结构代替数组

* 哈希表
* 二叉查找树
* TST

~~~go
type Node struct{
    end bool //单次结束符
    next []*Node //考虑哈希表或二叉查找树
}

type Trie struct{
    root *Node
    size int
}

func NewTrie()*Trie{
    return &Trie{
        size:0,
        root:newNode(),
    }
}

func newNode()*Node{
    return &Node{
        end: false,
        next: make([]*Node, 128),
    }
}

~~~

##### 插入

~~~go
func (t *Trie) Insert(key string) {
	node := t.Find(key)
	if node != nil {
		return
	}
	insert(t.root, 0, key)
}
func insert(node *Node, index int, key string) {
	i := int(key[index])
	if node.next[i] == nil {
		node.next[i] = newNode()
	}
	if index == len(key)-1 {
		node.next[i].end = true
		return
	}
	insert(node.next[i], index+1, key)
}
~~~



##### 查找

从根开始，首先确定键中第一个字符所在节点。然后根据第二个字符在第一个字符维护的边数组中的节点。递归的搜索

* 找到
* 未找到有两种情况， 第一种是键的最后一个字符对应的节点的结束标志为false。第二种是某个字符对应的节点为空

~~~go
func (t *Trie) Find(key string) *Node {
	return find(t.root, 0, key)
}

func find(node *Node, index int, key string) *Node {
	i := int(key[index])
	next := node.next[i]
	if next == nil {
		return nil
	} else if index == len(key)-1 && !next.end {
		return nil
	} else if index == len(key)-1 && next.end {
		return next
	}
	return find(next, index+1, key)
}


~~~



##### 删除

~~~

~~~



##### 最长前缀

~~~go

~~~



##### 前缀匹配 找出包含指定前缀的所有字符串

~~~go
func (t *Trie) KeysWithPrefix(key string) []string {
	queue := make([]int, 0)
	return collect(t.root, 0, queue, key)
}

func collect(node *Node, index int, queue []int, key string) []string {
	k := key[index]
	if node.next[k] == nil {
		return nil
	}
	fmt.Printf("append:%s \n", string(k))
	queue = append(queue, int(k))
	if index == len(key)-1 {
		keys := make([]string, 0)
		if node.end {
			keys = append(keys, toString(queue))
		}
		queue = queue[:len(queue)-1]
		for i, pnext := range node.next {
			if pnext != nil {
				subKeys := make([]string, 0)
				subKeys = collectHelper(pnext, i, queue, subKeys)
				keys = append(keys, subKeys...)
			}
		}
		return keys
	}
	return collect(node.next[k], index+1, queue, key)
}

func toString(queue []int) string {
	data := make([]byte, len(queue))
	buf := bytes.NewBuffer(data)
	for _, e := range queue {
		buf.WriteRune(rune(e))
	}
	return buf.String()
}
func collectHelper(node *Node, index int, queue []int, keys []string) []string {

	queue = append(queue, index)
	if node.end {
		fmt.Printf("size:%d\n", len(queue))
		data := make([]byte, len(queue))
		buf := bytes.NewBuffer(data)
		for _, e := range queue {
			buf.WriteRune(rune(e))
		}
		key := buf.String()
		keys = append(keys, key)
		fmt.Printf("%s\n", key)
	}
	for i, pnext := range node.next {
		if pnext == nil {
			continue
		}
		fmt.Printf("index:%s\n", string(i))
		keys = collectHelper(pnext, i, queue, keys)
	}
	return keys
}

~~~





#### 三向查找树(TST)

下图左边是普通Trie的表示，右图是TST的表示





![1597052633341](${img}/1597052633341.png)







在TST中，左链接表示位于同一层但小于当前节点键值(字符)的节点，右链接表示位于同一层但大于当前节点键值的的节点。中间的链接表示等于当前节点键值的下一个节点

![1597053005920](${img}/1597053005920.png)



##### 定义

~~~go
type tstNode struct{
    end bool
    left *tstNode
    middle *tstNode
    right *tstNode
    ch rune
}

type Tst struct{
    root *tstNode
    size int
}

func NewTst()*Tst{
    return &Tst{}
}

func newTstNode(ch rune, end bool)*tstNode{
    return &tstNode{
        ch : ch,
        end:end,
    }
}
~~~

##### 查找

~~~go
func (t *Tst)Find(key string){
    return find(t.root, 0, key)
}

func find(node *tstNode, index int, key string)*tstNode{
    if node == nil{
        return nil
    }
    k := key[index]
    if index == len(key){
        if node.ch == k && node.end{
            return node
        }else if node.ch == k && !node.end{
            return nil
        }     
    }
    if node.ch == k{
        return find(node.middle, index+1, key)
    }else if k < node.ch{
        return find(node.left, index, key)
    }
    return find(node.right, index, key)
}
~~~



##### 插入

~~~go
func (t *Tst)Insert(key){
    t.root = insert(t.root, index, key)
}

func insert(node *tstNode, index, key string)*tstNode{
    if node == nil{
        end := false
        if index == len(key)-1{
            end = true
        }
        node = &newTstNode(key[index], end)
        if index == len(key)-1{
            return node
        }
    }
    k := key[index]
    if node.ch == k{
        node.middle = insert(node.middle, index+1, key)
    }else if k < node.ch{
        node.left= insert(node.left, index, key)
    }else{
        node.right insert(node.right, index, key)
    }
    return node
}
~~~



##### 删除

~~~

~~~



### suffix trie

##### 定义

以给定文本的全部后缀建立一个trie

例如给定文本abaaba, 其所有的后缀及后缀建立的trie如下图所示

~~~
a$
ba$
aba$
aaba$
baaba$
abaaba$
~~~



![image-20200811142552031](${img}/image-20200811142552031.png)



文本后面加$字符的原因:

![image-20200811142919609](${img}/image-20200811142919609.png)



##### 应用

* 给定字符串s,确定其是否是字符串T的子串
* 统计某子串出现的次数
* 找出最长重复出现的子串



确定是否是子串的方法:

![image-20200811143543484](${img}/image-20200811143543484.png)



![image-20200811144320392](${img}/image-20200811144320392.png)

### suffix tree

##### 应用

* 模式匹配(pattern searching)（文本搜索)
* 搜索最长重复出现的子串(finding longest repeated substring)
* 搜索最长的通用子串(finding the longest common substring)

### suffix array



### 参考

* trie 及TST的介绍 https://courses.cs.washington.edu/courses/cse373/20wi/lectures/19-tries/19-tries.pdf
* 后缀树(suffix tree)https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf
* suffix trie http://211.136.65.135/cache/www.cs.jhu.edu/~langmea/resources/lecture_notes/tries_and_suffix_tries.pdf?ich_args2=127-11122514055275_eb0fb5500a76fb5f169515f2f91429f1_10001002_9c896d2bd6c2f8d89232518939a83798_46e451b020eeac6097b27e90a19b7934 