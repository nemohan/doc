# 字符串算法

[TOC]

### 常见的字符串存储结构

* 单词查找树trie
* 后缀树(suffix trie、suffix tree)
* 后缀数组(suffix array)

### 字符串排序

##### 键索引计数法

##### 低位优先的字符串排序



### 单词查找树(字典树)

#### trie(try发音)

trie是一棵树，每个节点有n条边（边的数目以存储的字符的字符表大小而定，若只存储包含a-z的字符串，则n就是26。若存储ascii字符，则大小为128）。每个节v点对应一个字符，对应的字符由其父节点p指向当前子节点边隐式确定

查找指定的字符串的时间复杂度是O(L),L是字符串长度

![1597038081877](${img}/1597038081877.png)



![1597038113269](${img}/1597038113269.png)

###### 应用

* 前缀匹配 keysWithPrefix("sa")， 找出前缀为指定字串的所有字符串
* 最长前缀longestPrefixOf("sample"),  找出含有给定字串的最长前缀的字符串

###### Trie的定义

使用数组表示边，会产生很多浪费。可以使用以下几种结构代替数组

* 哈希表
* 二叉查找树
* TST

~~~go
type Node struct{
    end bool //字符串结束标志
    next []*Node //考虑哈希表或二叉查找树
}

type Trie struct{
    root *Node
    size int
    value interface{}
}

func NewTrie()*Trie{
    return &Trie{
        size:0,
        root:newNode(),
    }
}

func newNode()*Node{
    return &Node{
        end: false,
        next: make([]*Node, 128),
    }
}


~~~

###### 获取所有的键

~~~go
func (t *Trie) Keys() []string {
	keys := make([]string, 0)
	for i, n := range t.root.next {
		if n == nil {
			continue
		}
		s := string(i)
		if n.end {
			keys = append(keys, s)
		}
		keys = collectV2(string(i), n, keys)
	}
	return keys
}

func collectV2(key string, node *Node, keys []string) []string {
	for i, n := range node.next {
		if n == nil {
			continue
		}
		//key = key + string(i)
		if n.end {
			keys = append(keys, key+string(i))
		}
		keys = collectV2(key+string(i), n, keys)
	}
	return keys
}
~~~



###### 插入

插入指定的字符串s时，依次插入`s[i],  0<=i < len(s)`。若s[i]已经在树中，则不做操作继续插入s[i+1]；若s[i]不在树中则将其插入

~~~go
func (t *Trie) Insert(key string) {
	node := t.Find(key)
	if node != nil {
		return
	}
	insert(t.root, 0, key)
}
func insert(node *Node, index int, key string) {
	i := int(key[index])
	if node.next[i] == nil {
		node.next[i] = newNode()
	}
	if index == len(key)-1 {
		node.next[i].end = true
		return
	}
	insert(node.next[i], index+1, key)
}
~~~

###### 查找

查找指定的键s。从根开始，依次查找s[i]  0 <= i < len(s)

查找的结果有下面三种情况：

* 找到，键的最后一个字符在树中，且end标志为true
* 未找到, 键的最后一个字符对应的节点的结束标志为false
* 未找到，键的某个字符对应的节点为空

~~~go
func (t *Trie) Find(key string) *Node {
	return find(t.root, 0, key)
}

func find(node *Node, index int, key string) *Node {
	i := int(key[index])
	next := node.next[i]
	if next == nil {
		return nil
	} else if index == len(key)-1 && !next.end {
		return nil
	} else if index == len(key)-1 && next.end {
		return next
	}
	return find(next, index+1, key)
}

~~~

###### 删除

~~~go
func delete(node *Node, index int, key string) *Node {
	k := key[index]
	next := node.next[k]
	if next == nil {
		return node
	}
	if index == len(key)-1 {
		if next.end {
			if hasChildren(next) {
				next.end = false
			} else {
				node.next[k] = nil
			}
			return node
		} else {
			return node
		}
	}
	node.next[k] = delete(next, index+1, key)
	if hasChildren(node.next[k]) {
		return node
	}
	if !node.next[k].end {
		node.next[k] = nil
	}
	return node
}
~~~

##### 最长前缀

#####　前缀匹配 找出包含指定前缀的所有字符串

~~~go
func (t *Trie) KeysWithPrefix(key string) []string {
	return collect(t.root, 0, key)
}

func collect(node *Node, index int, key string) []string {
	k := key[index]
	if node.next[k] == nil {
		return nil
	}
	if index == len(key)-1 {
		keys := make([]string, 0)
		if node.next[k].end {
			keys = append(keys, key)
		}
		for _, pnext := range node.next {
			if pnext == nil {
				continue
			}
			//keys = collectV2(key+string(i), pnext, keys)
			keys = collectV2(key, pnext, keys)
		}
		return keys
	}
	return collect(node.next[k], index+1, key)
}
~~~





#### 三向查找树(TST)

下图左边是普通Trie的表示，右图是TST的表示





![1597052633341](${img}/1597052633341.png)







在TST中，左链接表示位于同一层但小于当前节点值(字符)的节点，右链接表示位于同一层但大于当前节点值的的节点。中间的链接表示等于当前节点值的下一个节点

![1597053005920](${img}/1597053005920.png)



##### 定义

~~~go
type tstNode struct {
	end    bool
	left   *tstNode
	middle *tstNode
	right  *tstNode
	ch     byte
}

type Tst struct {
	root *tstNode
	size int
}

func NewTst() *Tst {
	return &Tst{}
}

func newTstNode(ch byte, end bool) *tstNode {
	return &tstNode{
		ch:  ch,
		end: end,
	}
}
~~~

##### 查找

~~~go
func tstFind(node *tstNode, index int, key string) *tstNode {
	if node == nil {
		return nil
	}
	k := key[index]
	if index == len(key)-1 {
		if node.ch == k && node.end {
			return node
		} else if node.ch == k && !node.end {
			return nil
		}
		//k less or greater than k

	}
	if node.ch == k {
		return tstFind(node.middle, index+1, key)
	} else if k < node.ch {
		return tstFind(node.left, index, key)
	}
	return tstFind(node.right, index, key)
}
~~~



##### 插入

~~~go
func (t *Tst) Insert(key string) {
	t.root = tstInsert(t.root, 0, key)
}

/*
 a(true)  s
 w(true)  a
 l		  d(true)
 s(true)
*/
func tstInsert(node *tstNode, index int, key string) *tstNode {
	if node == nil {
		node = newTstNode(key[index], false)
		if index == len(key)-1 {
			node.end = true
			return node
		}
	}

	k := key[index]
	if node.ch == k {
		if index == len(key)-1 {
			node.end = true
			return node
		}
		node.middle = tstInsert(node.middle, index+1, key)
	} else if k < node.ch {
		node.left = tstInsert(node.left, index, key)
	} else {
		node.right = tstInsert(node.right, index, key)
	}
	return node
}
~~~



##### 获取三向树含有的所有键

~~~go
func (t *Tst) Keys() []string {
	keys := make([]string, 0)
	keys = tstCollect(t.root, "", keys)
	return keys
}

func tstCollect(node *tstNode, key string, keys []string) []string {
	if node.end {
		keys = append(keys, key+string(node.ch))
	}
	if node.middle != nil {
		keys = tstCollect(node.middle, key+string(node.ch), keys)
	}
	if node.left != nil {
		keys = tstCollect(node.left, key, keys)
	}
	if node.right != nil {
		keys = tstCollect(node.right, key, keys)
	}
	return keys
}

~~~

##### 删除

~~~go

~~~



### suffix trie(后缀树)

##### 定义

以给定字符串的全部后缀建立一个trie

例如给定文本abaaba, 其所有的后缀及后缀建立的trie如下图所示

~~~
a$
ba$
aba$
aaba$
baaba$
abaaba$
~~~



![image-20200811142552031](${img}/image-20200811142552031.png)



文本后面加$字符的原因:

![image-20200811142919609](${img}/image-20200811142919609.png)



##### 应用

* 给定字符串s,确定其是否是字符串T的子串
* 统计某子串出现的次数
* 找出最长重复出现的子串



确定是否是子串的方法:

![image-20200811143543484](${img}/image-20200811143543484.png)



![image-20200811144320392](${img}/image-20200811144320392.png)

### suffix tree

<<<<<<< HEAD
A suffix tree **T** for a m-character string S is a rooted directed tree with exactly m leaves numbered 1 to **m.** (Given that last string character is unique in string)

- Root can have zero, one or more children.
- Each internal node, other than the root, has at least two children.
- Each edge is labelled with a nonempty substring of S.
- No two edges coming out of same node can have edge-labels beginning with the same character.

Concatenation of the edge-labels on the path from the root to leaf i gives the suffix of S that starts at position i, i.e. S[i…m].

**Note:** Position starts with 1 (it’s not zero indexed, but later, while code implementation, we will used zero indexed position)

![image-20200811201014624](${img}/image-20200811201014624.png)


=======
待学习
>>>>>>> 39e23326dff25d00e3fce8fe7285e1df7286cdac

##### 应用

* 模式匹配(pattern searching)（文本搜索)
* 搜索最长重复出现的子串(finding longest repeated substring)
* 搜索最长的通用子串(finding the longest common substring)

### suffix array

<<<<<<< HEAD
给定字符串的所有后缀,  所有后缀排序后生成的数组即suffix array, 下面是字符串banana的后缀数组

~~~
Let the given string be "banana".

0 banana                          5 a
1 anana     Sort the Suffixes     3 ana
2 nana      ---------------->     1 anana  
3 ana        alphabetically       0 banana  
4 na                              4 na   
5 a                               2 nana

So the suffix array for "banana" is {5, 3, 1, 0, 4, 2}
~~~




=======
待学习
>>>>>>> 39e23326dff25d00e3fce8fe7285e1df7286cdac

### 参考

* trie 及TST的介绍 https://courses.cs.washington.edu/courses/cse373/20wi/lectures/19-tries/19-tries.pdf
<<<<<<< HEAD
* 后缀树(suffix tree)https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf,  https://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/ 

* suffix trie http://211.136.65.135/cache/www.cs.jhu.edu/~langmea/resources/lecture_notes/tries_and_suffix_tries.pdf?ich_args2=127-11122514055275_eb0fb5500a76fb5f169515f2f91429f1_10001002_9c896d2bd6c2f8d89232518939a83798_46e451b020eeac6097b27e90a19b7934 
=======
* 后缀树(suffix tree)https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf
* suffix trie http://211.136.65.135/cache/www.cs.jhu.edu/~langmea/resources/lecture_notes/tries_and_suffix_tries.pdf?ich_args2=127-11122514055275_eb0fb5500a76fb5f169515f2f91429f1_10001002_9c896d2bd6c2f8d89232518939a83798_46e451b020eeac6097b27e90a19b7934 
* 后缀数组(suffix array ) https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixarrays.pdf
>>>>>>> 39e23326dff25d00e3fce8fe7285e1df7286cdac
