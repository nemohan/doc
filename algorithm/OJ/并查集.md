# 并查集(union-find)

[TOC]



### 朋友圈问题

班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

示例 1:

输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
示例 2:

输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
注意：

N 在[1,200]的范围内。
对于所有学生，有M[i][i] = 1。
如果有M[i][j] = 1，则有M[j][i] = 1。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/friend-circles
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



##### 实现

~~~go
func findCircleNum(M [][]int) int {
    n := len(M[0])
    set := make([]int, n)
    for i := range set{
        set[i] = i
    }
    for i, row := range M{
        for j, v :=range row{
            if i != j && v ==1{
                union(i, j, set)
            }
        }
    }
 
    count := 0
    for i, v := range set{
        if v == i{
            count++
        }
    }
    return count
}


func union(i, j int, set []int){
    root := set[i]
    rootj := set[j]
    if root == rootj{
        return
    }

    set[i] = rootj
    for k, v := range set{
        if v == root {
            set[k] = rootj
        }
    }
}
~~~



##### 结果

![image-20200728163526542](${img}/image-20200728163526542.png)



##### 优化

~~~go
func findCircleNum(M [][]int) int {
    n := len(M[0])
    set := make([]int, n)
    for i := range set{
        set[i] = i
    }
    for i, row := range M{
        for j, v :=range row{
            if i != j && v ==1{
                union(i, j, set)
            }
        }
    }
 
    count := 0
    for i, v := range set{
        if v == i{
            count++
        }
    }
    return count
}


func union(i, j int, set []int){
    root := set[i]
    rootj := set[j]
    
    for root != set[root]{
        root = set[root]
    }
    
    for rootj != set[rootj]{
        rootj=set[rootj]
    }
    set[root] = rootj
}
~~~



##### 结果

![image-20200728165600920](${img}/image-20200728165600920.png)



### 721. Accounts Merge（账号合并)

Medium

1471298Share

Given a list `accounts`, each element `accounts[i]` is a list of strings, where the first element `accounts[i][0]` is a *name*, and the rest of the elements are *emails* representing emails of the account.

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails **in sorted order**. The accounts themselves can be returned in any order.

**Example 1:**

```
Input: 
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
Explanation: 
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
```



**Note:**

The length of `accounts` will be in the range `[1, 1000]`.

The length of `accounts[i]` will be in the range `[1, 10]`.

The length of `accounts[i][j]` will be in the range `[1, 30]`.