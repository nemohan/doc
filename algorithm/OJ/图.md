# 图

[TOC]

求解图相关的OJ习题的一般思路：

* 首先确定用无向图还是有向图表示问题
* 确定图的表示方法邻接矩阵还是邻接表
* 确定使用的算法

刷这部分题时，可以直接使用前面给出的图的代码模板

在leetcode中给定的输入都是边

#### 小镇法官问题

难度简单72收藏分享切换为英文关注反馈

在一个小镇里，按从 `1` 到 `N` 标记了 `N` 个人。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：

1. 小镇的法官不相信任何人。
2. 每个人（除了小镇法官外）都信任小镇的法官。
3. 只有一个人同时满足属性 1 和属性 2 。

给定数组 `trust`，该数组由信任对 `trust[i] = [a, b]` 组成，表示标记为 `a` 的人信任标记为 `b` 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 `-1`。

 

**示例 1：**

```
输入：N = 2, trust = [[1,2]]
输出：2
```

**示例 2：**

```
输入：N = 3, trust = [[1,3],[2,3]]
输出：3
```

**示例 3：**

```
输入：N = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
```

**示例 4：**

```
输入：N = 3, trust = [[1,2],[2,3]]
输出：-1
```

**示例 5：**

```
输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
输出：3
```

 

**提示：**

1. `1 <= N <= 1000`
2. `trust.length <= 10000`
3. `trust[i]` 是完全不同的
4. `trust[i][0] != trust[i][1]`
5. `1 <= trust[i][0], trust[i][1] <= N`



##### 求解

思路是法官顶点的入度必为N-1,出度未0

~~~go
func findJudge(N int, trust [][]int) int {
    if N == 1{
        return 1
    }
    table := make(map[int]int, N)
    in := make(map[int]int, N)
    candidates := make([]int, 0)
    //出度、入度统计
    for _, row := range trust{
        table[row[0]] += 1
        v := row[1]
        tmp := in[v]
        tmp++
        in[v]=tmp
        if tmp == N-1{
            candidates = append(candidates, v)
        }
    }
    
    for _, k := range candidates{
            //没有出度
            if _, ok := table[k]; !ok{
                return k
            }
        
    }
    return -1
}
~~~



##### 结果

思路正确，效率不甚理想



![1596200953243](${img}/1596200953243.png)







#### [1042. 不邻接植花](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)

难度简单

有 `N` 个花园，按从 `1` 到 `N` 标记。在每个花园中，你打算种下四种花之一。

`paths[i] = [x, y]` 描述了花园 `x` 到花园 `y` 的双向路径。

另外，没有花园有 3 条以上的路径可以进入或者离开。

你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。

以数组形式返回选择的方案作为答案 `answer`，其中 `answer[i]` 为在第 `(i+1)` 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。

 

**示例 1：**

```
输入：N = 3, paths = [[1,2],[2,3],[3,1]]
输出：[1,2,3]
```

**示例 2：**

```
输入：N = 4, paths = [[1,2],[3,4]]
输出：[1,2,1,2]
```

**示例 3：**

```
输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
输出：[1,2,3,4]
```

 

**提示：**

- `1 <= N <= 10000`
- `0 <= paths.size <= 20000`
- 不存在花园有 4 条或者更多路径可以进入或离开。
- 保证存在答案。



##### 求解

根据题目看每个节点最多与三个顶点相连，且相邻顶点颜色不能重复。使用无向图来表示问题，广度优先遍历会检查与每个顶点相邻的顶点，此时可以确定合适的顶点颜色确保没有冲突。

* 根据提供的边二维数组建立以邻接表表示的无向图
* 广度优先遍历建立的无向图
* 遍历时根据当前顶点的所有临接点已使用的颜色来挑选未使用的颜色

~~~go


type Graph struct{
    size int
    vertexs [][]int
    
}


func (g *Graph)addEdge(start, end int){
    g.vertexs[start] = append(g.vertexs[start], end)
    g.vertexs[end] = append(g.vertexs[end], start)
}



func (g *Graph)bfs(start int, colors []int)[]int{
    queue := []int{}
    //colors := make([]int, g.size)
    if colors[start] == 0{
        colors[start] = 1
        queue = append(queue, start)
    }
    
    for len(queue) > 0{
        v := queue[0]
        for _, k := range g.vertexs[v]{
            if colors[k] == 0{
                queue = append(queue, k)
                colors[k] = getNextColor(g, k, colors)
            }
        }
        queue = queue[1:]
    }
    return colors
}

func getNextColor(g *Graph, v int, colors []int)int{
    vcolors := []int{0, 1, 2, 3, 4}
    for _, k := range g.vertexs[v]{
        c := colors[k]
        if c != 0{
            vcolors[c] = 0
        }
    }
    for _, c := range vcolors{
        if c != 0{
            return c
        }
    }
    return -1
}

func gardenNoAdj(N int, paths [][]int) []int {
    if N == 1{
        return []int{1}
    }
    g := &Graph{
        size:N+1,
        vertexs: make([][]int, N+1),
    }
   // colorTable := make(map[int]int, N)
    for _, path := range paths{
        g.addEdge(path[0], path[1])
    }
    colors := make([]int, N+1)
    for i := 1; i <= N; i++{
        colors = g.bfs(i, colors)
    }
    return colors[1:]
}
~~~



##### 结果

![1596245497696](${img}/1596245497696.png)



#### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

难度中等137收藏分享切换为英文关注反馈

在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1：**

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2：**

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意:**

- 输入的二维数组大小在 3 到 1000。
- 二维数组中的整数在1到N之间，其中N是输入数组的大小。



##### 求解

检查是否有环







#### [841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

难度中等92收藏分享切换为英文关注反馈

有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。

最初，除 `0` 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 `true`，否则返回 `false`。



**示例 1：**

```
输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
```

**示例 2：**

```
输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。
```

**提示：**

1. `1 <= rooms.length <= 1000`
2. `0 <= rooms[i].length <= 1000`
3. 所有房间中的钥匙数量总计不超过 `3000`。



##### 求解

根据输入的rooms建立有向图，`rooms[i][j] =v`即表示顶点i到顶点v之间有一条边(i, v)。然后使用深度优先遍历或广度优先遍历即可

考察要点即深度优先遍历

~~~go
type DiGraph struct{
    vertexes []int
    size int
    edges [][]int
}

func (g *DiGraph)addEdge(start, end int){
    g.vertexes[start]=start
    g.vertexes[end] = end
    g.edges[start] = append(g.edges[start], end)
}

//顶点的临接顶点表
func (g *DiGraph)adjs(v int)[]int{
    return g.edges[v]
}

func canVisitAllRooms(rooms [][]int) bool {
    roomSize := len(rooms)
    g := &DiGraph{
        size:roomSize,
        edges: make([][]int, roomSize),
        vertexes: make([]int, roomSize),
                 }
    
    for i, room := range rooms{
        for _, v := range room{
            g.addEdge(i, v)
        }
    }
    marked := make([]bool, g.size)
    Dfs(g, 0, marked)
                                 for _, v := range marked{
                                     if !v{
                                         return false
                                     }
                                 }
                                 return true
                                 
}

func Dfs(g *DiGraph, start int, marked []bool){
    marked[start] = true
    for _, v := range g.adjs(start){
        if !marked[v]{
            Dfs(g, v, marked)
        }
    }
}
~~~



##### 结果:

![1596270373349](${img}/1596270373349.png)

#### [1306. 跳跃游戏 III](https://leetcode-cn.com/problems/jump-game-iii/)

难度中等

这里有一个非负整数数组 `arr`，你最开始位于该数组的起始下标 `start` 处。当你位于下标 `i` 处时，你可以跳到 `i + arr[i]` 或者 `i - arr[i]`。

请你判断自己是否能够跳到对应元素值为 0 的 **任一** 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

 

**示例 1：**

```
输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 
```

**示例 2：**

```
输入：arr = [4,2,3,0,3,1,2], start = 0
输出：true 
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 0 -> 下标 4 -> 下标 1 -> 下标 3
```

**示例 3：**

```
输入：arr = [3,0,2,1,2], start = 2
输出：false
解释：无法到达值为 0 的下标 1 处。 
```

 

**提示：**

- `1 <= arr.length <= 5 * 10^4`
- `0 <= arr[i] < arr.length`
- `0 <= start < arr.length`



##### 求解

关键在于如何根据提供的输入建立图、能否从一个下标到达另一个下标即确定两个顶点之间是否存在路径

* 顶点个数即输入的数组长度
* **哪两个下标（顶点）之间是否有边通过i+arr[i]`(i+arr[i] < len(arr))`,及i-arr[i]`(i -arr[i] > 0)`确定, 假设输入arr = [4,2,3,0,3,1,2]，0 + arr[0] = 4则顶点0和顶点4之间有一条边， 0-arr[0] < 0没有边1+ arr[1]=3则顶点1和3之间有一条边, 1-arr[1]<0没有边**
* 深度优先遍历确定路径

图的定义以及深度优先遍历使用了之前的模板

~~~go
func NewGraph(size int)*Graph{
    return &Graph{
        vertexes : make([]int, size),
        edges: make([][]int, size),
    }
}
type Graph struct{
    vertexes []int
    edges [][]int
}

func (g *Graph)Size()int{
    return len(g.vertexes)
}

func (g *Graph)AddEdge(start, end int){
    g.vertexes[start]=start
    g.vertexes[end]=end
    
    g.edges[start] = append(g.edges[start], end)
    //g.edges[end] = append(g.edges[end], start)
}
//顶点的临接顶点表
func (g *Graph)Adjs(v int)[]int{
    return g.edges[v]
}

func (g *Graph)Vertexes()[]int{
    return g.vertexes
}


func canReach(arr []int, start int) bool {
    size := len(arr)
    g := NewGraph(size)
    table := make(map[int]bool, 0)
    j := -1
    for i, v := range arr{
        if i == start && v == 0{
            return true
        }
        s := i+v
        e := i-v
        if s < size && s != i{
            g.AddEdge(i, s)
        }
        if e >= 0 && e != i{
            g.AddEdge(i, e)
        }
        if v == 0{
            j = i
            table[i] = false
        }
    }
    
    if j == -1{
        return false
    }

    marked := make([]bool, size)
    dfs(g, start, marked)
    for k := range table{
        if marked[k]{
            return true
        }
    }
    return false
}

func dfs(g *Graph, start int, marked []bool){
    marked[start] = true
    for _, v := range g.Adjs(start){
        if !marked[v]{
            dfs(g, v, marked)
        }
    }
}
~~~



##### 结果

提交了4、5次才成功，之前的提交失败有几种边界情况未考虑

* start下标处的值为0， 入用例[0,0] 0
* 多个下标的值是0
* 图的模型，开始用了无向图。应该用有向图

![1596270082963](${img}/1596270082963.png)