# 队列



Write a class `RecentCounter` to count recent requests.

It has only one method: `ping(int t)`, where t represents some time in milliseconds.

Return the number of `ping`s that have been made from 3000 milliseconds ago until now.

Any ping with time in `[t - 3000, t]` will count, including the current ping.

It is guaranteed that every call to `ping` uses a strictly larger value of `t` than before.

 

**Example 1:**

```
Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]
Output: [null,1,2,3,3]
```

 

**Note:**

1. Each test case will have at most `10000` calls to `ping`.
2. Each test case will call `ping` with strictly increasing values of `t`.
3. Each call to ping will have `1 <= t <= 10^9`.

##### 算法

~~~go

type RecentCounter struct {

    queue []int
}


func Constructor() RecentCounter {
    return RecentCounter{
    }
}


func (this *RecentCounter) Ping(t int) int {
    this.queue = append(this.queue, t)
    l := t - 3000
    if l < 0{
        l = 0
    }
    n := 0
    for j := len(this.queue)-1; j >= 0; j--{
        if this.queue[j] <=t && this.queue[j] >= l{
            n++
        }
    }
    return n
}
~~~



##### 结果

![image-20200609173342913](E:\doc\algorithm\OJ\${img}\image-20200609173342913.png)





##### 改进之后的实现

~~~go

type MyQueue struct{
    data []int
    max int
    size int
    front int
    rear int
}

func NewQueue(size int)*MyQueue{
    return &MyQueue{
        max: size,
        data: make([]int, size),
    }
}

func (q *MyQueue)isEmpty()bool{
    if q.size == 0{
        return true
    }
    return false
}
func (q *MyQueue)isFull()bool{
    if q.size == q.max{
        return true
    }
    return false
}
func (q *MyQueue)enQueue(k int){
    if q.isFull(){
        panic("is full")
    }
    q.data[q.rear] = k
    q.rear = (q.rear +1) %q.max
    q.size++
}
func (q *MyQueue)deQueue(){
    if q.isEmpty(){
        panic("is empty")
    }
    q.front = (q.front +1) %q.max
    q.size--
}

func (q *MyQueue)get(i int)int{
    return q.data[i]
}


type RecentCounter struct {

    queue *MyQueue
}


func Constructor() RecentCounter {
    return RecentCounter{
        queue: NewQueue(3001),
    }
}


func (this *RecentCounter) Ping(t int) int {
    l := t - 3000
    if l < 0{
        l = 0
    }
    n := 0
    size := this.queue.size
    j := this.queue.front
    for size > 0{
        size--
        tmp := this.queue.get(j)
        if tmp <=t && tmp >= l{
            n++
        }else if tmp < l{
            this.queue.deQueue()
        }
        j = (j+1)% this.queue.max
    }
    this.queue.enQueue(t)
    return n+1
}
~~~



##### 运行结果

效率不降反增,有点意思

![image-20200618165029677](E:\doc\algorithm\OJ\${img}\image-20200618165029677.png)