# 并查集(UNION-FIND)

### 并查集解决的问题

* 连通性问题，如给定一个整数对序列0-2，1-4、2-5、3-6、0-4、6-0确定整数对1-3之间是否联通
* 集合问题，确定两个元素是否属于同一集合

### 算法的实现

##### 快速查找

以上面的联通性问题为例，使用一个大小为N,第i个元素得值为i, 0<=i <N。若整数对p-q联通则有a[p] = q。为实现p 和q得合并操作。把所有值为p的元素的值改为q或反之

~~~go
func quikFind(a []int, p, q int)bool{
    if a[p] == a[q]{
        return true
    }
    for i := 0; i < len(a); i++{
        if a[i] == a[q]{
            a[i] = a[p]
        }
    }
    return false
}
~~~


| 输入 | 0 1 2 3 4 5 6 |
| ---- | ------------- |
| 0-2  | 0 1 0 3 4 5 6 |
| 1-4  | 0 1 0 3 1 5 6 |
| 2-5  | 0 1 0 3 1 0 6 |
| 3-6  | 0 1 0 3 1 0 3 |
| 0-4  | 0 1 0 3 0 0 3 |


对N个对象的连通性问题，M次合并操作快速查找算法至少需要执行MN条指令。一次合并指合并p-q

##### 快速合并(quick-union)

在快速合并算法中，第i个元素的值指向同一集合中的另一个对象(既另一对象的数组下标值)。要确定两个对象(p-q)是否在同一个集合中只需跟随每个对象的指针直到到达指向自身的对象(a[i] == i)。当且仅当这个过程使得两个对象(p-q)到达同一个对象时(i)，这两个对象在同一集合中。

为了构造合并，只需将一个对象指向另一个对象。

~~~go
func quickUnion(a []int, p, q int)bool{
    s := p
    d := q
    for a[s] != s{
        s = a[s]
    }
    for a[d] != d{
        d = a[d]
    }
    if s == d{
        return true
    }
    //a[p] = q, 错在哪。错在未将两个集合合并成一个
    a[s]=d
    return false
}
~~~



| 输入 | 0 1 2 3 4 5 6 |
| ---- | ------------- |
| 0-2  | 0 1 0 3 4 5 6 |
| 1-4  | 0 1 0 3 1 5 6 |
| 2-5  | 0 1 0 3 1 2 6 |
| 3-6  | 0 1 0 3 1 2 3 |
| 0-4  | 0 1 0 3 0 2 3 |

性质: 对于M > N, 快速合并算法求解N个对象，M个对的连通问题需要执行MN/2条指令

在合并操作中，不是任意地把第二颗树连接到第一棵树上，而是记录每棵树中的节点数，总是把较小的树连接到较大的树上。减小树的高度，可以大大提升效率，此算法就是加权快速合并

#####　加权快速合并



~~~go
//数组sz 保存每棵树中节点数目
func quickUnion(a []int, p, q int)bool{
    s := p
    d := q
    for a[s] != s{
        s = a[s]
    }
    for a[d] != d{
        d = a[d]
    }
    if s == d{
        return true
    }
    if sz[s] < sz[d]{
        a[s] = d
    }else{
        a[d] = s
    }
    return false
}

~~~



当归并集合的大小总是相等时，出现最坏情况。如对2的n次方节点做归并，树的高度不超过n。

性质：对于N个对象，加权快速合并算法判定其中的两个对象是否连通，至多需要遍历2LgN个指针。

对于M > N, 快速合并算法求解N个对象，M个对的连通问题需要执行MLgN条指令

##### 路径压缩
