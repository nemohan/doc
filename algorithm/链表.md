# 链表

[TOC]

现在发现自己有时候写链表的时候，每次都是一个新版本。有带表头的、有不带的，大部分时间不带表头，有时候对表头的设置也有点疑惑。现在彻底实现一遍，对比一下差异

## 单链表

### 总结



### 带表头

~~~go
package list

type listNode struct {
	value int
	next  *listNode
}

type LinkList struct {
	head  *listNode
	count int
}

func NewLinkList() LinkList {
	return LinkList{head: &listNode{}}
}

func (l *LinkList) AddHead(val int) {
	node := &listNode{value: val}
	node.next = l.head.next
	l.head.next = node
	l.count++
}

func (l *LinkList) AddTatil() {

}

func (l *LinkList) Find(val int) int {
	p := l.head.next
	for ; p != nil && p.value != val; p = p.next {
	}
	if p == nil {
		return -1
	}
	return p.value
}

func (l *LinkList) RemoveHead() {
	pn := l.head.next
	if pn == nil {
		return
	}
	l.head.next = pn.next
	pn.next = nil
	l.count--
}

//Len 元素个数 O(1)
func (l *LinkList) Len() int {
	return l.count
}

func (l *LinkList) Remove(val int) {
	prev := l.head
	p := l.head.next

	for ; p != nil && p.value != val; p = p.next {
		prev = p
	}
	if p == nil {
		return
	}
	/*
		//head element
		if prev == l.head.next {
			l.list = p.next
			p.next = nil
			l.count--
			return
		}
	*/
	prev.next = p.next
	p.next = nil
	l.count--
}
~~~



### 不带表头

~~~go
package list

type listNode struct {
	value int
	next  *listNode
}

type LinkList struct {
	list  *listNode
	count int
}

func NewLinkList() LinkList {
	return LinkList{}
}

func (l *LinkList) AddHead(val int) {
	node := &listNode{value: val}
	node.next = l.list
	l.list = node
	l.count++
}

func (l *LinkList) AddTatil() {

}

func (l *LinkList) Find(val int) int {
	p := l.list
	for ; p != nil && p.value != val; p = p.next {
	}
	if p == nil {
		return -1
	}
	return p.value
}

func (l *LinkList) RemoveHead() {
	if l.list == nil {
		return
	}
	pn := l.list
	l.list = pn.next
	pn.next = nil
	l.count--
}

//Len 元素个数 O(1)
func (l *LinkList) Len() int {
	return l.count
}

func (l *LinkList) Remove(val int) {
	prev := l.list
	p := l.list

	for ; p != nil && p.value != val; p = p.next {
		prev = p
	}
	if p == nil {
		return
	}
	//head element
	if prev == l.list {
		l.list = p.next
		p.next = nil
		l.count--
		return
	}
	prev.next = p.next
	p.next = nil
	l.count--
}
~~~





## 双向链表



### 带表头

### 不带表头

