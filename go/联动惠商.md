~~~go

package pos

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"crypto/sha1"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"sort"
	"strconv"

	"github.com/shopspring/decimal"

	"github.com/spf13/viper"
)

type kvPair struct {
	key   string
	value string
}

var (
	codeOk             = "0000"
	codeOrderNotExists = "88881122" //订单不存在
	codeOrderFailed    = "88881136" //订单失败
	codeOrderRefundOK  = "88881137"
)
var (
	errOrderNotExists     = errors.New("order not exists")
	errOrderOk            = errors.New("ok")
	errOrderMoneyNotMatch = errors.New("money not match")
	errOrderFailed        = errors.New("order failed")
	errRefundFailed       = errors.New("refund failed")
)

func IsOrderOk(no string, amount decimal.Decimal) (bool, error) {
	return isOrderStausOk(no, amount)
}
func isOrderStausOk(outTradeNo string, payAmount decimal.Decimal) (bool, error) {
	orderParams := map[string]string{
		"partnerOrderId": outTradeNo,
	}
	addr := "http://mofunapi.umfintech.com/in-pay-client/api/apisync"
	resp, err := queryOrderStatus(orderParams, addr)
	log.Printf("isOrderStatusok resp:%v\n", resp)
	if err != nil {
		return false, err
	}
	retCode := resp["retCode"]
	if retCode == codeOrderNotExists {
		return false, errOrderNotExists
	}
	if retCode == codeOrderFailed {
		return false, errOrderFailed
	}
	if retCode != codeOk {
		return false, fmt.Errorf("unkown code:%s %v\n", retCode, resp)
	}
	amount, err := strconv.Atoi(resp["amount"])
	if err != nil {
		return false, err
	}
	if !payAmount.Equal(decimal.NewFromFloat(float64(amount) / float64(100))) {
		log.Println("amount", amount)
		log.Println("amount decimal", decimal.NewFromFloat(float64(amount)/float64(100)))
		log.Println("payAmount", payAmount)

		return false, errOrderMoneyNotMatch
	}
	return true, nil
}

func IsRefundOrderStatusOk(outTradeNo, refundTradeNo string, payAmount decimal.Decimal) (bool, error) {
	//y, m, d := time.Now().Date()
	//addr := "https://mofunapi.umfintech.com/in-pay-client/refund/query"

	addr := "http://mofunapi.umfintech.com/in-pay-client/api/apisync"
	params := map[string]string{
		"partnerOrderId": outTradeNo,
		//"refundPartnerOrderId": refundTradeNo,
		//"reqDate":              fmt.Sprintf("%d%02d%02d", y, m, d),
		//"reqTime":              time.Now().Format("150405"),
	}
	resp, err := queryOrderStatus(params, addr)
	log.Printf("IsRefundOrderStatusOk resp:%v", resp)
	if err != nil {
		log.Printf("QueryRefundOrderStatus failed. resp %v, err %v", resp, err)
		return false, err
	}

	retCode := resp["retCode"]
	if retCode == codeOrderNotExists {
		return false, errOrderNotExists
	}
	if retCode == codeOrderFailed {
		return false, errOrderFailed
	}
	if retCode != codeOrderRefundOK {
		return false, fmt.Errorf("unkown code:%s %v\n", retCode, resp)
	}
	amount, err := strconv.Atoi(resp["amount"])
	if err != nil {
		return false, err
	}
	if !payAmount.Equal(decimal.NewFromFloat(float64(amount) / float64(100))) {
		return false, errOrderMoneyNotMatch
	}

	return true, nil
}

//从惠商后台查询订单状态
func queryOrderStatus(orderParams map[string]string, addr string) (map[string]string, error) {
	signKeyFile := viper.GetString("posSignPrivateKeyFile")
	keyData, err := ioutil.ReadFile(signKeyFile)
	if err != nil {
		//return nil, err
		panic(err)
	}
	privateKey, err := x509.ParsePKCS8PrivateKey(keyData)
	if err != nil {
		return nil, err
	}
	rsaPrivateKey := privateKey.(*rsa.PrivateKey)

	posSubMerId := viper.GetString("posSubMerId")
	proxyId := viper.GetString("posProxyId")
	params := map[string]string{
		"subMerId": posSubMerId,
		"proxyId":  proxyId,
		//"partnerOrderId": outTradeNo,
		"apiVersion": "1.0",
		//"sign":           "",
	}
	for k, v := range orderParams {
		params[k] = v
	}

	kvs := genSortedParams(params)
	buf := bytes.NewBufferString("")
	for _, kv := range kvs {
		buf.WriteString(fmt.Sprintf("%s=%s&", kv.key, kv.value))
	}
	buf.Truncate(buf.Len() - 1)
	param := buf.String()
	fmt.Printf("query param:%s  \n", param)

	hashed := sha1.Sum([]byte(param))
	signParam, err := rsa.SignPKCS1v15(nil, rsaPrivateKey, crypto.SHA1, hashed[:])
	if err != nil {
		//panic(err)
		return nil, err
	}

	fmt.Printf("signParam:%s\n", string(signParam))
	signedStr := base64.StdEncoding.EncodeToString(signParam)
	params["sign"] = signedStr
	data, _ := json.Marshal(params)
	strData := url.QueryEscape(string(data))

	reader := bytes.NewBuffer([]byte("context=" + string(strData)))

	/*
		resp, err := http.Post("http://mofunapi.umfintech.com/in-pay-client/api/apisync",
			"application/x-www-form-urlencoded", reader)
	*/
	resp, err := http.Post(addr, "application/x-www-form-urlencoded", reader)
	if err != nil {
		//panic(err)
		return nil, err
	}
	defer resp.Body.Close()
	respBuf := make([]byte, 1024)
	n, _ := resp.Body.Read(respBuf)
	fmt.Printf("%s\n", string(respBuf))
	return verifyResult(string(respBuf[:n]))
}

func genSortedParams(params map[string]string) []*kvPair {
	kvs := make([]*kvPair, 0)
	for k, v := range params {
		if v == "" {
			continue
		}
		kv := &kvPair{
			key:   k,
			value: v,
		}
		kvs = append(kvs, kv)
	}
	sort.Slice(kvs, func(i, j int) bool {
		return kvs[i].key < kvs[j].key
	})
	return kvs
}

func verifyResult(result string) (map[string]string, error) {
	table := make(map[string]string, 0)
	if err := json.Unmarshal([]byte(result), &table); err != nil {
		return nil, err
	}
	sign := table["sign"]
	delete(table, "sign")

	kvs := genSortedParams(table)
	buf := bytes.NewBufferString("")
	for _, kv := range kvs {
		buf.WriteString(fmt.Sprintf("%s|", kv.value))
	}
	buf.Truncate(buf.Len() - 1)
	signParam := buf.String()
	fmt.Printf("verify signParam:%s\n", signParam)

	verifyKeyFile := viper.GetString("posVerifyKeyFile")
	keyData, err := ioutil.ReadFile(verifyKeyFile)
	if err != nil {
		panic(err)
	}
	cert, err := x509.ParseCertificate(keyData)
	if err != nil {
		//panic(err)
		return nil, err
	}
	signBytes, err := base64.StdEncoding.DecodeString(sign)
	if err != nil {
		//panic(err)
		return nil, err
	}
	if err := cert.CheckSignature(x509.SHA1WithRSA, []byte(signParam), signBytes); err != nil {
		//panic(err)
		return nil, err
	}
	return table, nil
}

~~~

