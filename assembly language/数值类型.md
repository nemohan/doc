# 数值类型

### 数值类型的表示方式

#### 无符号整型的表示方式

所有的位用来表示

#### 有符号整型的表示方式

##### 符号位

以一个字节大小的整数为例

在这种表示方式中，最高位为符号位。若是正整数则符号位为0，若是负整数则符号位为1。在这种方式下整数0有两种表示方式，分别是0000 0000(正0)和1000 0000(负0)

| 十进制整数 | 对应的二进制表示       |
| ---------- | ---------------------- |
| -1         | 1000 0001              |
| 1          | 0000 0001              |
| 0          | 0000 0000 和 1000 0000 |

这种方式也导致1(0000 0001)加-1(1000 0001)得到-2(1000 0010)这种情况，若采用这种方式将针对无符号和有符号整数使用不同的指令

##### one's complement(反码)

以一个字节大小的整数为例

正整数的表示：最高位为0

负整数的表示:  通过将对应的正整数取反来得到负整数的二进制表示，比如1(0000 0001)取反得到-1(1111 1110)

0的表示: 0000 0000 和1111 1111(-0)

##### two's complement(补码)

以一个字节大小的整数为例

正整数的表示: 最高位为0

负整数的表示: 通过将对应的正整数取反，然后再加1得到。比如1(0000 0001)取反得到1111 1110 再加1得-1(1111 1111)

0的表示:  0000 0000

##### 为什么采用补码表示有符号整数





##### 总结

在汇编中，整型运算使用一套指令。运算结果得解读取决于EFLAGS寄存器中标志位得使用



### 浮点数

![image-20191218111533744](E:\doc\assembly language\${img}\image-20191218111533744.png)

##### 规格化(normalized value)

最常见情况，<font color='red'>exp部分既不是全0也不是全1(单精度情况下，值255或2047双精度情况下)</font>。这种情况下，exp(指数部分)表示的有符号的偏置值。即 E= 2的exp次方 - Bias。 Bias=2的(k-1)次方-1(假设exp部分由k位组成，如单精度8位)。

小数部分M的计算：

小数部分frac的小数值为f(0 <=f  <10)，其二进制表示0.f(n-1)...f1f0。M=1+f

![image-20191218121305518](E:\doc\assembly language\${img}\image-20191218121305518.png)

##### 非规格化(Denormalized

指数部分exp为全0,这种形式的浮点数为非规格化的。在这种情况下E=1-Bias, 小数部分M=f。

非规格化数字有两个作用:

* 可以表示数值0。规格化的数值总有M >=1，所以不能表示0。+0.0的二进制位全部是0：即符号位s是0，指数部分exp全为0，小数部分也是0(M=f=0)。当符号位s是1，其他位全部为0时，我们便得到了-0.0。在IEEE规定的浮点格式中，-0.0和+0.0有时相同有时不同
* 可以表示非常接近于0.0的数值

![image-20191218121608798](E:\doc\assembly language\${img}\image-20191218121608798.png)

##### 特殊数值

指数部分为全1，小数部分为全0得到的值表示无穷。当s(符号位)为0时是正无穷，为1时是负无穷。当把两个非常大的数相乘，或除0时，无穷能够表示溢出的结果。

当小数部分非零时，结果值被称为NaN(Not a Number)。一些运算结果不能为实数或无穷时，就返回NaN

示例：

~~~
示例: 假设现在用6位表示浮点数。符号位s占1位，指数部分exp占3位，小数部分占2位。则能表示的规格化浮点数的最大范围是-14~14。

14 的计算: V= (-1) 的s次方* M * 2的E次方。

小数部分M: 最大的小数的二进制表示为f=0.11即 (1/2+1/4)，最终的M=(1+F)(1+1/2+1/4)

指数部分: E = e -Bias =6-3=3； e 为6因为exp不能全为1，Bias=3=2的(3-1)次方-1


~~~



练习:

有如下的用5位表示的遵循IEEE浮点格式的浮点数。符号位占1位，指数部分exp占2位(k=2), 小数部分占2位(n=2)。指数部分的偏置值 2的(2-1)次方 减1(Bias=1)

| Bits     | E(小写) | E                           | f       | M       | V       |
| -------- | ------- | --------------------------- | ------- | ------- | ------- |
| 0  00 00 | 0       | 0                           | 0/4     | 0/4     | 0/4     |
| 0  00 01 | 0       | <font color='red'>-1</font> | 1/4     | 0/4     | 1/4     |
| 0  00 10 | 0       | <font color='red'>-1</font> | 2/4     | 0/4     | 2/4     |
| 0  00 11 | 0       | <font color='red'>-1</font> | 3/4     | 0/4     | 3/4     |
| 0  01 00 | 1       | 0                           | 0/4     | 4/4     | 4/4     |
| 0  01 01 | 1       | 0                           | 1/4     | 4/4     | 5/4     |
| 0  01 10 | 1       | 0                           | 2/4     | 4/4     | 6/4     |
| 0  01 11 | 1       | 0                           | 3/4     | 4/4     | 7/4     |
| 0  10 00 | **2**   | **1**                       | **0/4** | **4/4** | **8/4** |
| 0  10 01 | 2       | 1                           | 1/4     | 4/4     | 10/4    |
| 0  10 10 | 2       | 1                           | 2/4     | 4/4     | 12/4    |
| 0  10 11 | 2       | 1                           | 3/4     | 4/4     | 14/4    |
| 0  11 00 | --      | --                          | --      | --      | +无穷   |
| 0  11 01 | --      | --                          | --      | --      | NaN     |
| 0  11 10 | --      | --                          | --      | --      | NaN     |
| 0 11 11  | --      | --                          | --      | --      | NaN     |



##### 遵循IEEE浮点数格式的一些属性

具有k位指数部分和n位小数部分的浮点数的一些属性

* +0.0 所有的位都是0

* 最小的非规格化正数: 小数部分的最低位是1，其他位都是0。小数部分M=f=2的-n次方。指数部分E= (1-Bias)= 1 - ((2 的k-1次方) -1)。V=E*M

* 最大的非规格化正数: 小数部分都是1，指数部分都是0。指数部分E=(1-Bias)= 1 -((2的k-1次方)-1)， M=f=1-(2的-n次方)

* 最小的规格化正数: 指数部分的最低位为1,其他位都是0(包括小数部分),M=1, E=e-Bias= (2的0次方*1) - ((2的k-1次方)-1)。V=E*M

* 1.0:  指数部分的最高位为1，其他位都是0。M=1, E=0

* 最大的规格化正数: 指数部分除了最低位是0，当然符号位也是0，其他都是1。M的值如下
  $$
  M= 1+f = 1 +(1 - 2^{-n})
  $$
  E = e - Bias
  $$
  e = 2^{k} - 1- 1
  $$

  $$
  Bias= 2^{k-1} -1
  $$

  $$
  E = e-Bias = 2^{k-1} -1
  $$

  V：
  $$
  V=(-1)^{s}*M*2^{E}
  $$

  $$
  V=(-1)^{s}*M*2^{E}=
  $$

  

计算由浮点数的二进制表示转为10进制时容易混用规格化和非规格化下的E、M的计算公式



##### Rounding (舍入)

浮点数的能表示的范围和精度是有限的，浮点运算只能近似数学上的实数计算。

IEEE提供了4种Rounding 模式:

第一种用来找到最接近的值，后三种用来确定上下边界

* Round-to-even(round-to-nearest): 这是默认的Round模式，Round-to-even mode adopts the convention that it rounds the number either upward or downward such that the **<u>least significant digit</u>** of the result is even。(least significant digit是什么意思 ？ 最低有效数字是偶数)
* Round-to-zero: Round-to-zero 向下round正数(趋近于0)，如1.60 向下round后是1. 向上round负数(趋近于0), 如-1.50向上round是-1。|x'| < |x|其中x'是Round后的值。
* Round-down: 正数和负数都向下Round, 即x' <= x
* Round-up: 正数和负数都向上Round, 即 x' >= x

![image-20191220113722899](E:\doc\assembly language\${img}\image-20191220113722899.png)



![image-20191220120037574](E:\doc\assembly language\${img}\image-20191220120037574.png)

##### 浮点运算

浮点运算支持交换性、不支持结合性即x+(y+z) != (x+y)+z

### 溢出

