盛付通

~~~go
package api

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha1"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

const (
	//testAddr = "http://10.132.97.134:8084/mnp-facade/txnQuery"
	testAddr       = "http://61.152.90.49:8090/mnp-facade/txnQuery"
	productionAddr = "http://posmnp.shengpay.com/mnp-facade/txnQuery"
)

type queryParam struct {
	DataType   string `json:"dataType,omitempty"`   //盛付通应答数据格式
	TxnType    string `json:"txnType,omitempty"`    //交易类型
	MerchantId string `json:"merchantId,omitempty"` //15位少年宫呼号
	MerOrderId string `json:"merOrderId,omitempty"` //商户订单
	TxnDate    string `json:"txnDate,omitempty"`    //交易日期，若为空，则默认当天交易  yyyyMMDD
	ExtData    string `json:"extData,omitempty"`    //附加信息，可为空
	Sign       string `json:"sign,omitempty"`       //签名
}

type queryResp struct {
	TxnType    string //交易类型
	Cur        string //交易货币类型
	AMT        string //交易金额,以分为单位
	MerchantId string //商户号
	TerminalId string //终端号
	TraceNo    string ///终端流水号
	BatchNo    string //终端批次号
	OrderId    string //盛付通订单号
	TxnTime    string //交易时间
	TxnRef     string //交易参考号
	RespCode   string //交易状态
	RespMsg    string //交易响应消息
	MerOrderId string //商户订单号
	ShortPan   string //卡号末4位
	ExtData    string //附加信息
	Sign       string //签名
}

const (
	testMerchantPrivateKey = "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAILFLdmFwfNHCGk3vpwj/FR9XpE9jjVreLlOaIEkSAOWOfzxCF7pMeSy0UDroRLgfLD4nQbUcK5AT7gg8PEM6H99SEHcpBkTKhfK1iI5iU9sN/WGL2Ft5T/uwo+KD7X3CsqMD0HsMQtv/YHJeAz/SPf5zyD5KttwohXXzO8a3P1pAgMBAAECgYAchxl2f6iNAu0Bzyhk9bDBWcw8kRop6zUd7836hkizh51E4ew6kFLTGnNt3zl3XcO187aF2+htCxiZCY6md3NstJod1zshoXf2slxxPWRUK92sS0XzlVT6ahVTdq2tAS3hOY3ldtnfOXMmMQPNn9OqlALQGOH/hJatBV6ZQxpp0QJBAMGKsxJkg3M6sZEO4zUgWgnGN+uS6nwAWpCfBY7eDvYSN78BxGGLgn+t40c0R8M/n85IM8OUmfHxTGWN3hYyGuUCQQCs+Kg1ypul9XLTWrVApyvZxY4ZxjAWG4yW4xqbUtHWUkGyle7Dy8xiYezl0kWN81lJNTz3qrJ4ZvM825+7tPw1AkBDPNxZV3ITZiCqNHHa0xJ0sthajv/HdJgCBjz4FU09T7buNL705HLByLdc1VzZCBGMqKjTGZ0h4KKZ5V9ydpXBAkABpZx0Zql0uxGM0aBILU9Nk4P22tw6WajNBvyJ3hABamcVvDe5xYb8qNIInifrYhXHjKo38XghjVljivPKZb7BAkAt4pCUYLI7LzLeSh/lnVxA7jOaRI3UsngCXn9VA4f+dkNcKAftRQqe7ytudqG07GKoInnDiyjrYe4kTLym8zoc"
	testMerchantPubKey     = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCCxS3ZhcHzRwhpN76cI/xUfV6RPY41a3i5TmiBJEgDljn88Qhe6THkstFA66ES4Hyw+J0G1HCuQE+4IPDxDOh/fUhB3KQZEyoXytYiOYlPbDf1hi9hbeU/7sKPig+19wrKjA9B7DELb/2ByXgM/0j3+c8g+SrbcKIV18zvGtz9aQIDAQAB"

	testPubKey           = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCdLPDIHhfBJKs4jhr6ZoJAyX+OpwT7jyvkeWBJvaEqc7if9zuVPz8qQCjaPr28Xm6GzHgsHo+lGlS6w3cyjKEboeV5wZs0I/yjkaoMRTAEekua4SrTxSvrds8666xKz2GRcZXhlVSo7izDs1Dn3nbL3npj7p1/FZYypg9PcxrugQIDAQAB"
	testPrivateKey       = "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJ0s8MgeF8EkqziOGvpmgkDJf46nBPuPK+R5YEm9oSpzuJ/3O5U/PypAKNo+vbxebobMeCwej6UaVLrDdzKMoRuh5XnBmzQj/KORqgxFMAR6S5rhKtPFK+t2zzrrrErPYZFxleGVVKjuLMOzUOfedsveemPunX8VljKmD09zGu6BAgMBAAECgYA9mrq5RQo8erndjd1HHdyZtiCX8iDC1Kf4ghZacMf1kqvfjxC8e7CvR7x7ZjIJ3d1mWkgTytq0dLCXDzvuBS6zv6i8In6zNor8F9lDGX0ysxe/PUcKzhuT1725p3OuTM/pDNXWtz8I1DF37FXyaOHzZLKJgTQ1M6PbTSiDhL0R0QJBAMw9cpyRoc5O0aARVmgHCtY8rvg3PXnl89vlvdSthj/YBkwqe+xrCuMY6OGIpt4asRBSuM+PibZo8F099NqkohUCQQDFAhLurH2pmg+V/ojt2bFVa8rm4r5WIfCs7NfhJ6Gk+Oqas7nNkgtR0vvrPztsDNnt5dSF8BDmVj2AJEFg9HG9AkBxRA6gp98dI/b7F0JdFLK81xCN1UzBonZX2BQrs0QFeg8cBF+PYFm8Ud8s3HT2LcVOcSHO8iKER7QtcaOt8al1AkEAq19XerkfgtZaMn89O7H/ma/vy5J4QdK6WqKYU+q2qRxCcBphSVp+cEoZDBVwKlivhktD6NLg0I06aGqhWKaq/QJAIVDAiZeS9Lxo9cAFUgo6C76GVgcm3GYOxfotRNkoCAMoodsEHEGTFglxVeQDdTsKsCagpjaaQ6q36bJexs1Uyw=="
	testSignData         = `SCPCNY100820600200006932AA00083700014038597142151406271111201406271702146688999900a3c70a8e46e34684b63f28c0a59a5b3a9999{"issuerCode":"WX","userId":"oybt7wcH4TkvA7lUxOQ7O04yb_ks"}`
	testMerchantSignData = "15470379490000012014041412121220140410"
	jsonDataType         = "1"
)

//getPubKey 获取公钥
func getPubKey() (*rsa.PublicKey, error) {
	data, err := base64.StdEncoding.DecodeString(testPubKey)
	if err != nil {
		return nil, err
	}
	key, err := x509.ParsePKIXPublicKey([]byte(data))
	if err != nil {
		return nil, err
	}
	return key.(*rsa.PublicKey), nil
}

func getPrivKey() (*rsa.PrivateKey, error) {
	data, err := base64.StdEncoding.DecodeString(testMerchantPrivateKey)
	if err != nil {
		return nil, err
	}
	key, err := x509.ParsePKCS8PrivateKey([]byte(data))
	if err != nil {
		return nil, err
	}
	privKey := key.(*rsa.PrivateKey)
	return privKey, nil
}

func QueryPay() {

	param := queryParam{
		DataType:   jsonDataType,
		TxnType:    "QRY",
		MerchantId: "547037949000001",
		MerOrderId: "20140414121212",
		TxnDate:    "20140410",
	}
	/*
		signData := param.DataType + param.TxnType + param.MerchantId +
			param.MerOrderId + param.TxnDate + param.ExtData
	*/
	signData := genSignData(&param)

	fmt.Printf("sign data:%s\n", signData)
	privKey, err := getPrivKey()
	if err != nil {
		panic(err)
	}
	hash := sha1.Sum([]byte(signData))
	signature, err := rsa.SignPKCS1v15(nil, privKey, crypto.SHA1, hash[:])
	if err != nil {
		panic(err)
	}

	strSigature := base64.StdEncoding.EncodeToString(signature)
	fmt.Printf("sign %v\n", strSigature)
	param.Sign = strSigature
	form := genForm(&param)
	fmt.Printf("form:%v\n", form)

	resp, err := http.PostForm(testAddr, form)
	if err != nil {
		panic(err)
	}
	buf := make([]byte, resp.ContentLength)
	resp.Body.Read(buf)
	defer resp.Body.Close()
	fmt.Printf("len:%d resp: %s\n", resp.ContentLength, string(buf))
	payResp := &queryResp{}
	json.Unmarshal(buf, payResp)
	fmt.Printf("%v\n", payResp)
	pubKey, err := getPubKey()
	if err != nil {
		panic(err)
	}
	verifySignature(payResp, payResp.Sign, pubKey)
}

//genForm 生成表单
func genForm(data interface{}) url.Values {
	values := make(url.Values)
	value := reflect.ValueOf(data).Elem()
	num := value.NumField()
	valueT := value.Type()
	for i := 0; i < num; i++ {
		v := value.Field(i)
		sf := valueT.Field(i)
		switch v.Kind() {
		case reflect.String:
			str := v.String()
			tag := string(sf.Tag)
			tagName := ""
			if tag != "" && strings.HasPrefix(tag, "json:") {
				tag = strings.Trim(strings.TrimPrefix(tag, "json:"), `"`)
				items := strings.Split(tag, ",")
				if len(items) > 0 {
					tagName = items[0]
				}
			}
			if str != "" && tagName != "" {
				values.Add(tagName, str)
			}
		}
	}
	return values
}

func genSignData(data interface{}) string {
	signData := ""
	value := reflect.ValueOf(data).Elem()
	num := value.NumField()
	valueT := value.Type()
	for i := 0; i < num; i++ {
		f := value.Field(i)
		sf := valueT.Field(i)
		if strings.ToLower(sf.Name) == "sign" {
			continue
		}
		switch f.Kind() {
		case reflect.String:
			v := f.String()
			if v != "" && v != "{}" {
				signData += v
			}
		}
	}
	fmt.Printf("signData:%s\n", signData)
	return signData
}

//genSignature 生成签名
func genSignature(data interface{}, privKey *rsa.PrivateKey) string {
	signData := genSignData(data)
	hash := sha1.Sum([]byte(signData))
	signature, err := rsa.SignPKCS1v15(nil, privKey, crypto.SHA1, hash[:])
	if err != nil {
		panic(err)
	}
	return base64.StdEncoding.EncodeToString(signature)
}

//verifySignature 签名验证
func verifySignature(data interface{}, sign string, pubKey *rsa.PublicKey) bool {
	signData := genSignData(data)
	hash := sha1.Sum([]byte(signData))
	decodedSign, err := base64.StdEncoding.DecodeString(sign)
	if err != nil {
		panic(err)
	}
	if err := rsa.VerifyPKCS1v15(pubKey, crypto.SHA1, hash[:], decodedSign); err != nil {
		panic(err)
	}
	fmt.Printf("verify ok\n")
	return true
}

~~~

