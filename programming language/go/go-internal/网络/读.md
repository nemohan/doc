# 读tcp链接

[TOC]

### 总结

* 没有设置读取超时时间时，直接调用conn.Read是立即返回呢，还是阻塞直到有数据可读。最后的结论是会一直等到数据可读
* tcp链接是否可以并发读写（读-读并发)

##### conn.Read

net/net.go

* 读取len(b)的字节数，读到的字节数小于等于len(b)

~~~go
// Implementation of the Conn interface.

// Read implements the Conn Read method.
func (c *conn) Read(b []byte) (int, error) {
	if !c.ok() {
		return 0, syscall.EINVAL
	}
	n, err := c.fd.Read(b)
	if err != nil && err != io.EOF {
		err = &OpError{Op: "read", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
	}
	return n, err
}
~~~



##### conn.ok

net/net.go

~~~go
func (c *conn) ok() bool { return c != nil && c.fd != nil }
~~~



##### netFD.Read

net/fd_unix.go

* 加读锁，fd.readLock
* <font color="red">检查缓冲区的长度，若长度为0，立即返回</font>

* 新的tcp链接被设置为非阻塞，所以调用syscall.Read会返回syscall.EAGAIN。然后调用pd.waitRead进入等待状态,若没有设置超时时间，则一直等待IO就绪或被关闭

~~~go
func (fd *netFD) Read(p []byte) (n int, err error) {
	if err := fd.readLock(); err != nil {
		return 0, err
	}
	defer fd.readUnlock()
	if len(p) == 0 {
		// If the caller wanted a zero byte read, return immediately
		// without trying. (But after acquiring the readLock.) Otherwise
		// syscall.Read returns 0, nil and eofError turns that into
		// io.EOF.
		// TODO(bradfitz): make it wait for readability? (Issue 15735)
		return 0, nil
	}
	if err := fd.pd.prepareRead(); err != nil {
		return 0, err
	}
	if fd.isStream && len(p) > 1<<30 {
		p = p[:1<<30]
	}
	for {
		n, err = syscall.Read(fd.sysfd, p)
		if err != nil {
			n = 0
			if err == syscall.EAGAIN {
				if err = fd.pd.waitRead(); err == nil {
					continue
				}
			}
		}
		err = fd.eofError(n, err)
		break
	}
	if _, ok := err.(syscall.Errno); ok {
		err = os.NewSyscallError("read", err)
	}
	return
}
~~~

##### syscall.Read

syscall/syscall_unix.go

~~~go
func Read(fd int, p []byte) (n int, err error) {
	n, err = read(fd, p)
	if race.Enabled {
		if n > 0 {
			race.WriteRange(unsafe.Pointer(&p[0]), n)
		}
		if err == nil {
			race.Acquire(unsafe.Pointer(&ioSync))
		}
	}
	if msanenabled && n > 0 {
		msanWrite(unsafe.Pointer(&p[0]), n)
	}
	return
}
~~~



##### syscall.read

syscall/zsyscall_linux_386.go

~~~go
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func read(fd int, p []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
~~~



##### netFD.eofError

~~~go
// eofError returns io.EOF when fd is available for reading end of
// file.
func (fd *netFD) eofError(n int, err error) error {
	if n == 0 && err == nil && fd.sotype != syscall.SOCK_DGRAM && fd.sotype != syscall.SOCK_RAW {
		return io.EOF
	}
	return err
}
~~~



#### 设置超时时间

##### conn.SetReadDeadline

net/net.go

~~~go
// SetReadDeadline implements the Conn SetReadDeadline method.
func (c *conn) SetReadDeadline(t time.Time) error {
	if !c.ok() {
		return syscall.EINVAL
	}
	if err := c.fd.setReadDeadline(t); err != nil {
		return &OpError{Op: "set", Net: c.fd.net, Source: nil, Addr: c.fd.laddr, Err: err}
	}
	return nil
}
~~~



##### netFD.setReadDeadline 设置读取超时时间

net/fd_poll_runtime.go

~~~go

func (fd *netFD) setReadDeadline(t time.Time) error {
	return setDeadlineImpl(fd, t, 'r')
}
~~~





##### setDeadlineImpl 设置超时时间

* 将时间转为纳秒

疑问:

* 为何调用fd.incref

~~~go
func setDeadlineImpl(fd *netFD, t time.Time, mode int) error {
	diff := int64(time.Until(t))
    //runtimeNano获取的是以纳秒为单位的时间么？？？
	d := runtimeNano() + diff
	if d <= 0 && diff > 0 {
		// If the user has a deadline in the future, but the delay calculation
		// overflows, then set the deadline to the maximum possible value.
		d = 1<<63 - 1
	}
	if t.IsZero() {
		d = 0
	}
	if err := fd.incref(); err != nil {
		return err
	}
	runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)
	fd.decref()
	return nil
}
~~~

